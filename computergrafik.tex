\chapter{Computergrafik}

Zusammenfassung der Vorlesung "`Computergrafik"' aus dem Wintersemester 2014.\footnote{\url{http://cg.ivd.kit.edu/lehre/ws2014/cg/index.php}}

\section{Farben, Bilder und Perzeption}

\subsection{Bilder, Darstellung und Framebuffer}

\subsubsection{Gammakorrektur}
\begin{itemize}
	\item Bilder sind oft zu hell oder zu dunkel
	\item Korrekturfunktion für das menschlichem Empfinden vpn physikalischen Helligkeitsunterschieden
	\item Ein idealer Monitor bildet einen Pixel-Wert \(n\) auf die Intensität \(I(n)\) ab
	\item Vergleichsweise wenige Stufen sind ausreichend
\end{itemize}


\subsection{Licht, Sehen und Wahrnehmung}

\subsubsection{Perzeption vs. Messung}
\begin{itemize}
	\item Das menschliche Auge kann die spektrale Zusammensetzung von Licht nicht erfassen
	\item Das Auge (und das Gehirn) macht eingeschränkte Messungen und passt sich den äußeren Umständen an
\end{itemize}

\subsubsection{Das Auge}
\begin{itemize}
	\item Zapfen: Für photopisches Sehen (Tagsehen) und trichromatisches Farbsehen. Blau (7\%), Grün (37\%), Rot (56\%)
	\item Stäbchen: Für skotopisches, monochromatisches Sehen (Nachtsehen); lichtempfindlicher, überall auf der Retina
\end{itemize}

\subsubsection{Farbmischungen}
\begin{itemize}
	\item \textbf{Additiv}
	\begin{itemize}
		\item RGB: \(C=rR+gG+bB\)
		\item Farbkombination durch Addition der Spektren
		\item Biologisch und technisch motiviert
		\item Anwendung: Monitore, Beamer
	\end{itemize}
	\item \textbf{Subtraktiv}
	\begin{itemize}
		\item CMY(K): Jede Primärfarbe absorbiert einen Teil des Spektrums; Key ist beim Druck meist Schwarz
		\item Dualer Farbraum zu RGB
		\item Farbkombination durch Multiplikation der Spektren
		\item Anwendung: Film, Farbstifte, Farbdrucker
	\end{itemize}
	\item \textbf{HSV}
	\begin{itemize}
		\item Farbton (Hue), Sättigung (Saturation) und Helligkeit (Value)
		\item Darstellung als Zylinder oder hexagonaler Kegel
		\item Anwendung: Benutzerschnittstellen, da intuitiv
	\end{itemize}
	\item \textbf{XYZ}
	\begin{itemize}
		\item Beschreibung aller wahrnehmbaren Farben
		\item Farbraum mit rein positiven Color Matching Funktionen
		\item Lineare Abbildung \[XYZ \Leftrightarrow RGB\]
	\end{itemize}
\end{itemize}

\subsubsection{Farbraum}
Die Menge der Farben, die mit einem bestimmten Modell beschrieben werden können.

\subsubsection{Graßmannsche Gesetze}
Jeder Farbeindruc kann mit drei Grundgrößen beschrieben werden.


\subsection{CIE Color Matching Functions}
\begin{itemize}
	\item Wahrnehmungsexperimente: Referenzfarbe vorgegeben, soll durch drei Grundfarben reproduziert werden
	\item Problem: Nicht alle Farben konnte reproduziert werden
	\item Lösung: Primärfarben als negativer Vergleichwert
\end{itemize}


\subsection{Weber-Fechner-Gesetz}
Die subjektiv empfundene Stärke von Sinneseindrücken ist proportional zum Logorithmus der Intensität des physikalisch Reizes (1:2 wird empfunden wie 100:200).


\subsection{Ray Tracing}
\begin{itemize}
	\item Idee: Geometrische Überlegungen über Lichtstrahlen
	\item Verfolge die Lichtstrahlen, die die Öffnung der Lochkamera passieren, finde Pixel, die das Objekt beeinflussen und bestimme Pixelfarbe
\end{itemize}


\subsection{Nyquist-Shannon-Abtasttheorem}
Ein kontinuierliches, bandbegrenztes Signal mit einer maximalen Frequenz \(f_{max}\) muss mit einer Frequenz größer \(2f_{max}\) abgetastet werden, damit aus dem diskreten Signal das Ursprungssignal exakt rekonstruiert werden kann.



\section{Ray Tracing}

\subsection{Grundbegriffe}

\subsubsection{Virtuelle Kamera}
Definiert durch:
\begin{itemize}
	\item Position und Blickrichtung
	\item Orientierung der vertikalen Achse
	\item Bildebene vor der Kamera
\end{itemize}

\subsubsection{Rasterisierung}
\begin{itemize}
	\item Idee: Transformation von Geometrie (3D auf 2D-Bildebene)
	\item Für alle Objekte: Finde Pixel, die das Objekt bedeckt und bestimme Pixelfarbe
\end{itemize}

\subsubsection{Bildsynthese}
\begin{itemize}
	\item Erzeuge ein Rasterbild aus einer Szenenbeschreibung (Objekte), also bestimme, welche Objekte die Farbe jedes Pixels beeinflussen
	\item \textbf{Objektbasiert (Object-Order Rendering)}
	\begin{enumerate}
		\item Betrachte ein Objekt/Fläche nach der anderen
		\item Finde heraus, welche Pixel das Objekt bedecken
		\item Bestimme die Pixelfarbe
	\end{enumerate}
	\item \textbf{Bildbasiert (Image-Order Rendering)}
	\begin{enumerate}
		\item Betrachte einen Pixel nach dem anderen
		\item Finde heraus, welches Objekt an dieser Stelle sichtbar ist
		\item Bestimme die Pixelfarbe
	\end{enumerate}
\end{itemize}

\subsubsection{Strahlentypen}
\begin{itemize}
	\item Sichtstrahl: Halbgerade von der Kamera durch den Pixel
\end{itemize}


\subsection{Prinzip}
\begin{itemize}
	\item Betrachte einen Pixel nach dem anderen (ray generation)
	\item Finde das Objekt, das die Kamera durch diesen Pixel sieht (ray intersection)
	\item Berechne Farbe und Schattierung (shading)
	\item Rekursive Fortsetzung der Strahlenverfolgung
\end{itemize}

\subsubsection{Prinzipielles Vorgehen im Detail}
\begin{enumerate}
	\item \textbf{ray generation}
	\begin{itemize}
		\item Erzeugung von Sichtstrahlen (vom Betrachter zur Bildebene) durch jeden Pixel der Bildebene
		\item Die Bildebene ist festgelegt durch den Abstand zur Kamera und die Größe der Ebene
		\item Typischerweise ist das Sichtfeld orthogonal mittleren Sichtstrahl und symmetrisch 
	\end{itemize}
	\item \textbf{ray intersection}
	\begin{itemize}
		\item Finde Objekt, das den Sichtstrahl schneidet und dessen Schnittpunkt der Kamera am nächsten ist
		\item Schnittpunktberechnung beispielsweise über Baryzentrische Koordinaten
	\end{itemize}
	\item \textbf{shading}
\end{enumerate}


\subsection{Materialeigenschaften}

\subsubsection{Schattierung/Beleuchtungsberechnung}
\begin{itemize}
	\item Essentiell für dreidimensionalen Eindruck
	\item Interaktion von Lichtquellen und Oberflächen
	\item \textbf{Extrema}
	\begin{itemize}
		\item Spekulare Reflexion: Einfallswinkel gleich Ausfallswinkel
		\item Diffuse (lambertsche) Reflexion: Gleiche Reflexion in alle Richtungen
	\end{itemize}
\end{itemize}

\subsubsection{Licht-Material-Interaktion}
Was passiert, wenn Licht auf eine Oberfläche trifft?
\begin{itemize}
	\item Ein Teil wird reflektiert
	\item Ein Teil dringt ins Material ein
	\item Das Verhältnis ist abhängig vom Einfallswinkel (\textit{Fresnel-Effekt}) und den Brechungsindizes beider Materialien
\end{itemize}

\subsubsection{Reflexion}
\begin{itemize}
	\item Diffus: Licht erhellt das Objekt gleichmäßig
	\item Glänzend (imperfekt spiegelnd): Licht wirft einen Kegel in Richtung Ausfallswinkel
	\item Spekular: Perfekte Spiegelung (Einfallswinkel = Ausfallswinkel)
\end{itemize}

\subsubsection{BRDFs}
Bidirektionale Reflektanz-Verteilungsfunktion (Bidirectional Reflectance Distribution Function)
\begin{itemize}
	\item Radiometrisches Konzept, um die Reflexion an einem Oberflächenpunkt zu beschreiben
	\item \textbf{Entwicklung von BRDFs}
	\begin{itemize}
		\item Messung von realen Materialproben mit einem Goniorereflektometer
		\item Phänomenologisch-motivierte Modelle: Wenige, intuitiv verständliche Parameter; nur in beschränktem Maße realistisch
		\item Physikalisch-motivierte Modelle: Exakte Resultate; Einstellung der Parameter allerdings schwierig
	\end{itemize}
\end{itemize}


\subsubsection{Phong-Bleuchtungsmodell}
Phänomologisches Modell, das die Reflexion mit drei Komponenten modelliert:
\begin{itemize}
	\item Ambient: Indirekte Beleuchtung, Licht von anderen Oberflächen
	\item Diffus: Nach dem Lambertschen Gesetz
	\item Spekular: Imperfekte Spiegelung
	\begin{itemize}
		\item Durch gerichtete Reflexion entstehen Glanzlichter
		\item Findet nur in Richtung des Ausfallswinkels statt (Geometrisch: Spiegelung des Lichtvektors an der Normalen)
		\item Größe des Fokus abhängig vom Phong-Exponenten (großer Exponent \(\rightarrow\) kleiner Kegel)
	\end{itemize}
\end{itemize}

\subsubsection{Formel zur Berechnung}
\[I = k_a\cdot I_L + k_d\cdot I_L \cdot (n\cdot L) + k_s\cdot I_L \cdot (R_L \cdot V)^n\]

\subsubsection{Stereo-Rendering}
\textbf{Idee:} Für jedes Auge ein anderes Bild durch die Einführung einer zweiten Kamera.

\subsubsection{Schattierung von Dreiecksnetzen}
\begin{itemize}
	\item Stückweise lineare Approximation einer (gekrümmten) Oberfläche durch Dreiecke
	\item Flat Shading: Verwendung der Dreiecksnormalen zur Beleuchtungsberechnung (Interpolation der Normalen der Eckpunkte)
	\item Scharfe Kanten brauchen mehrere Normalen
	\item Typischerweise werden drei Eckpunkte, drei Normalen sowie zusätzliche Attribute (beispielsweise Farben) gespeichert
	\item Phong Shading: Beleuchtungsberechnung mit interpolierten Normalen
\end{itemize}

\subsubsection{Licht und Schatten}
\begin{itemize}
	\item Objekte können Schatten werfen
	\item Schattenstrahl: Senden eines Strahls von der Oberfläche zur Lichtquelle hin, um zu gucken, ob ein anderes Objekt geschnitten wird
	\item Problem: Endliche Genauigkeit der Gleitkommadarstellung, dadurch treten Artefakte auf und die Strahl schneidet eventuell die Oberfläche von der er startet nochmal
	\item \textbf{Lösungen}
	\begin{itemize}
		\item Teste explizit, ob das geschnittene Objekt bereits geschnitten wurde
		\item Starte etwas weiter weg von der Oberfläche
	\end{itemize}
\end{itemize}

\subsubsection{Arten von Lichtquellen}
\begin{itemize}
	\item Punktlichtquellen: Definiert durch Position und Intensität. Bei realen Lichtquellen: Abfall der Intensität mit dem Abstandsquadrat
	\item Paralleles Licht: Definiert durch Richtung und Flussdichte, z.B. Sonnenlicht
	\item \textbf{Andere Lichtquellentypen}
	\begin{itemize}
		\item Strahler (Spot-Lights): Lichtkegel mit Abstrahlcharakteristik \(cos^n \Theta\)
		\item Flächenlichtquellen
		\item Punktlichtquellen mit Richtungscharakteristik
	\end{itemize}
\end{itemize}

\subsubsection{Primär- und Sekundärstrahlen}
\begin{itemize}
	\item Ray Tracing basiert auf den Gesetzen der geometrischen Optik
	\item Grundidee: Strahlenverfolgung vom Auge aus
	\item Rekursion um Spiegelung und Lichtbrechung darzustellen \(\rightarrow\) Sekundärstrahlen: Reflexionsstrahlen und Transmissionsstrahlen
	\item Steigende Genauigkeit mit steigender Rekursionstiefe
\end{itemize}

\subsubsection{Snellsches Brechungsgesetz}
\begin{itemize}
	\item Beschreiben der Richtungsänderung einer Welle (Licht) beim Übergang von einem Medium in ein anderes mit unterschiedlicher Brechungszahl
	\item Licht bewegt sich in unterschiedlichen Medien unterschiedlich schnell: \(\eta = \frac{c_{Vakuum}}{c_{Medium}}\)
	\item Die Brechzahl \(\eta\) ist wellenlängenabhängig \(\rightarrow\) Aufspaltung in unterschiedliche Wellenlängen (Dispersion)
	\item \textbf{Brechungsgesetz}
	\begin{itemize}
		\item \(\eta_i sin(\Theta_i) = \eta_t sin(\Theta_t)\)
		\item Übergang ins optisch dichtere Medium (\(\eta_t > \eta_i\)): Brechung zum Lot hin
		\item Übergang ins optisch dünnere Medium (\(\eta_t < \eta_i\)): Brechung vom Lot weg
	\end{itemize}
	\item Fresnel-Effekt: Verteilung der Strahlendichte
	\item Totalreflexion: Wird beim Übergang ein bestimmter Grenzwinkel überschritten wird der Strahl komplett reflektiert
\end{itemize}

\subsubsection{Aliasing}
\begin{itemize}
	\item Aliasing-Effekte entstehen durch (falsche) Abtastung von Signalen
	\item \textbf{Lösungsansätze}
	\begin{itemize}
		\item Filterung des Signals vor der Abtastung zur Entfernung von hohen Frequenzen: Im allgemeinen Fall nicht möglich
		\item Höhere Abtastrate des Signals und anschließend mitteln (Überabtastung, Supersampling)
	\end{itemize}
	\item Abtasttheorem von Nyquist und Shannon: Ein kuntinuierliches, bandbegrenztes Signal mit einer maximalen Frequenz \(f_{max}\) muss mit einer Frequenz größer als \(2f_{max}\) abgetastet werden, damit aus dem diskreten Signal das Ursprungssignal exakt rekonstruiert werden kann.
\end{itemize}

\subsubsection{Supersampling-Strategien}
\begin{itemize}
	\item \textbf{Uniformes Supersampling}
	\begin{itemize}
		\item Statt Abtastung eines Punktes innerhalb eines Pixels wird \(k^2\)-mal im selben Intervall abgetastet
		\item Abstand zwischen den Samples muss immer gleich sein
	\end{itemize}
	\item \textbf{Adaptives Supersampling}
	\begin{itemize}
		\item Heute kaum noch verwendet
		\item Ist die Farbdifferenz benachbarter Samples zu groß, dann werden die Pixel mehrfach unterteilt
		\item Einfarbige Pixel benötigen im Schnitt nur ein Sample, Kanten werden trotzdem geglättet
	\end{itemize}
	\item \textbf{Stochastisches Supersampling}
	\begin{itemize}
		\item Uniformes Supersampling oft nicht ausreichend für um hohe Frequenzen aufzulösen
		\item Unterteilt Pixel in ein Gitter und wählt zufällig einen Punkt pro Zelle (Stratified Sampling)
		\item Reduziert Alising, führt aber zu mehr Rauschen, was allerdings von der menschlichen Wahrnehmung als weniger störend empfunden wird
	\end{itemize}
\end{itemize}


\subsection{Distributed Ray Tracing}

\subsubsection{Probleme des Whitted-Style Ray Tracing}
\begin{itemize}
	\item Bilder sehen zu makellos aus
	\item Perfekte Spiegelung und Transmission
	\item Harte Schattenkanten
	\item Unendlich Schärfentiefe
\end{itemize}

\subsubsection{Weiche Schatten}
\begin{itemize}
	\item Reale Lichtquellen besitzen endliche Ausdehnung
	\item Schatten beginnen am Objekt mit harten Kanten, die mit wachsendem Abstand weicher werden
\end{itemize}

\subsubsection{Bewegungsunschärfe}
\begin{itemize}
	\item Verteilung der Strahlen in der Zeit: Objekte bewegen sich in einem Zeitintervall
	\item Erzeuge verschiedene Strahlen pro Pixel und mittlere die Farbwerte
	\item Vgl. Blichtungszeit bei realen Kameras
\end{itemize}

\subsubsection{Tiefenunschärfe}
\begin{itemize}
	\item "`Modell der dünnen Linse"'
	\item Verteilung der Strahlen in der Breite
	\item Wähle einen Punkt auf der Bildebene und der Linse und berechne dadurch den Punkt auf der Fokusebene
\end{itemize}

\subsection{Imperfekte Spiegelung und Transmission: Distributed Ray Tracing}
\begin{itemize}
	\item Mehrere Strahlen für Spiegelung und Transmission
	\item An jedem Schnittpunkt werden viele Sekundärstrahlen weiterverfolgt
	\item (Quasi-)zufällige Richtung
	\item Gewichtung nach der BRDF
	\item Durch Rekursion wird ein verzweigter "`Strahlenbaum"' aufgebaut
\end{itemize}



\section{Transformationen und homogene Koordinaten}
\begin{itemize}
	\item Eine Transformation bildet einen Punkt \(x\) auf einen Punkt \(x'\) ab
	\item Transformationen werden mit Abbildungsmatrizen beschrieben: \(T(x) = Ax\)
	\item Beispiele: Platzierung von Objekten, Animation, Deformation, Echtzeitschatten, usw.
\end{itemize}

\subsubsection{Grundlegende Transformationen}
\begin{itemize}
	\item Identität, Translation (Verschiebung), Rotation, isotrope Skalierung
	\item Können beliebig kombiniert werden
	\item Sind umkehrbar/invertierbar
\end{itemize}

\subsubsection{Transformationsgruppen}
\begin{itemize}
	\item Euklidische Transformationen: Erhalten Abstände, Inhaltsgrößen und Winkel (Translation, Identität, Rotation)
	\item Ähnlichkeiteabbildungen: Erhalten lediglich die Winkel (isotrope Skalierung, sowie alle euklidischen Transformationen)
	\item Lineare Abbildungen: Identität, Rotation, isotrope Skalierung, Skalierung, Spiegelung, Scherung
	\item Affine Abbildung: Parallele Linien werden erhalten (alle bisher genannten Abbildungen)
	\item Projektive Abbildungen: Geraden werden auf Geraden abgebildet (auch alle bisher genannten Abbildungen)
\end{itemize}


\subsection{2D Transformationen}
\begin{itemize}
	\item Beschreibung mittels Vektor-Matrix-Multiplikation
	\item Skalierung: Ändert Längen
	\item Scherung: Verschiebung parallel zu einer Achse (Flächeninhalt bleibt erhalten)
	\item Spiegelung: Spiegelungen sind negative Skalierungen
	\item Rotationen um den Winkel \(\phi\)
\end{itemize}

\subsubsection{Zusammengesetzte 2D Transformationen}
\begin{itemize}
	\item Hintereinanderausführen von Tranformationen
	\item Transformationen werden von rechts angewendet
	\item Im Allgemeinen nicht kommutativ: Reihenfolge ist entscheidend
\end{itemize}


\subsection{3D Transformationen}

\subsubsection{Rotation}
\begin{itemize}
	\item \(R_x\) dreht die \(y\)-Achse in Richtung \(z\)-Achse
	\item \(R_y\) dreht die \(z\)-Achse in Richtung \(x\)-Achse
	\item \(R_z\) dreht die \(x\)-Achse in Richtung \(y\)-Achse
\end{itemize}


\subsection{Affine Abbildungen}
\begin{itemize}
	\item Kombination aus linearer Abbildung und Translation
	\item \textbf{Eigenschaften}
	\begin{itemize}
		\item Linien werden auf Linien abgebildet, parallele Linien bleiben parallel
		\item Teilverhältnistreu
		\item Nicht winkelerhaltend
	\end{itemize}
	\item Beispiele: Rotation, Translation, Skalierung, Scherung
\end{itemize}


\subsection{Homogene Koordinaten}
\begin{itemize}
	\item Ergänzen den euklischen/affinen Raum um Fernpunkte
	\item Parallele Geraden schneiden sich
	\item Anwendung: Beschreiben von affinen Punkte und Richtungen, beschreiben von Translationen durch Matrizen
\end{itemize}

\subsubsection{Homogene Koordinaten bei affinen Abbildungen}
\begin{itemize}
	\item Ziel: Beschreibung von affinen Punkten und Richtungen, sowie affinen Abbildungen mit Matrizen
	\item Vorteil: Zusammengesetzte affine Transformation
	\item Hinzufügen einer \(1\) als dritte Koordinate (im 2D)
\end{itemize}


\subsection{Koordinatensysteme in der Computergrafik}
\begin{enumerate}
	\item Objektkoordinaten: Objekte in einer Szene werden zur Modellierung in ihrem eigenen Koordinatensystem angegeben
	\item Weltkoordinaten: Die Platzierung von Objekten erfolgt dann durch Translation, Rotation, Skalierung, etc.
	\item Kamerakoordinaten: Anschließend erfolgt die Transformation in das Kamerakoordinatensystem
\end{enumerate}


\subsection{Hierarchisches Modellieren}
\begin{itemize}
	\item Modellieren komplexer Szenen wird einfacher, wenn Kopien von Instanzen erstellt werden und Objekte zu Gruppen zusammengefasst werden
	\item Beispiel: Modell eines Autos mit Karosserie, Rädern, Reifen, Felgen und Schrauben
	\item Durch das Gruppieren von Objekten entsteht ein \textit{Szenengraph}
	\item Szenengraphen erlauben effiziente Operationen in komplexen Szenen
\end{itemize}


\subsection{Transformation von Normalen}
\begin{itemize}
	\item Lineare und affine Transformationen sind im Allgemeinen nicht winkeltreu \(\rightarrow\) Normalen können nicht einfach mittransformiert werden
	\item Verwendung von homogenen Koordinaten: Transformation der Tangentenebene zur Normalen, nicht den Normalenvektor selbst
\end{itemize}


\subsection{Transformationen und Schnitttests}
\begin{itemize}
	\item Schwierigkeit: Berechnung von Schnittpunkten bei zusammengesetzten Transformationen
	\item Idee: Schnittpunktberechnung in Modellkoordinaten
\end{itemize}



\section{Texturen}
\begin{itemize}
	\item Idee: Realistischeres Aussehen einer Oberfläche kann man durch "`Feinstrukturierung"' pro Pixel erreichen
	\item Geormetrie wird mit Bildern kombiniert
	\item Texture Mapping: Wie wird einem Punkt auf der Oberfläche eine Stelle in der Textur zugeordnet?
\end{itemize}


\subsection{Mapping von Texturen}
\begin{itemize}
	\item 1D Textur: Parameter entlang einer der drei Achsen
	\item \textbf{2D Textur}
	\begin{itemize}
		\item Planare Projektion eines Bildes in der \(x-Y\)-Ebene
		\item Standardkörper mit natürlicher Parametrisierung (z.B. Punkte auf einer Kugel lassen mittels Polarkoordinaten ausdrücken)
		\item Sphärische Koordinaten oder zyklindrische Parametrisierung: Darstellung der Objektkoordinaten in Polarkoordinaten
		\item Würfel Parametrisierung: Würfeltextur wird dort ausgelesen, wo ein Strahl vom Objektmittelpunkt einen umgebenden Würfel schneidet
		\item Flächenparameter: Beschreibung beispielsweise mit Hilfe von Bézier-/Splinepatches
	\end{itemize}
	\item Zweiphasen-Mapping: Texturierung beliebiger Objekte mit Standardkörpern als Zwischenschritte
\end{itemize}

\subsubsection{Texturkoordinaten für Dreiecksnetze}
\begin{itemize}
	\item Parametrisierung für jeden Vertrex wird in der Texturkoordinaten gespeichert
	\item Interpolation mit baryzentrischen Koordinaten
\end{itemize}

\subsubsection{Texture Wrapping}
\begin{itemize}
	\item Repeat/Wrapping: Fortsetzen einer Textur über \(\lbrack 0,1 \rbrack^2\) hinaus
	\item Adressierung wird für jede Dimension separat gewählt
\end{itemize}

\subsubsection{Texture Mapping und Aliasing}
\begin{itemize}
	\item Aliasingeffekte können durch Unterabtastung auftreten
	\item Entscheident: Verhältnis der Abtastfrequenz am Bildschirm zur Auflösung der projizierten Textur
\end{itemize}

\subsection{Texture Filterung}
\begin{itemize}
	\item \textbf{Vergrößerung (Magnification)}
	\begin{itemize}
		\item Abbildung weniger Texel auf viele Pixel
		\item Nearest Neighbor: Verwende Farbe des nächstliegenden Texels
		\item Bilineare Interpolation zur Glättung des Signals
	\end{itemize}
	\item \textbf{Textur-Filter}
	\begin{itemize}
		\item Die menschliche Wahrnehmung nimmt Unstetigkeiten nur bis zur zweiten Ableitug wahr \(\rightarrow\) Verwendung von Interpolation höherer Ordnung
		\item Bikubische Interpolation (benötigt Zugriff auf \(4~x~4\) Texel
	\end{itemize}
	\item \textbf{Verkleinerung (Minification)}
	\begin{itemize}
		\item Abbildung mehrerer Texel auf einen Pixel
		\item Wird nur ein Texel ausgelesen, obwohl der Pixel im Texturraum mehrere Texel bedeckt entstehen Aliasing-Artefakte durch Unterabtastung
		\item Möglichkeiten
		\begin{itemize}
			\item Vorfilterung des Signals (hohe Frequenzen vor der Abtastung entfernen)
			\item Überabtastung/Supersamling (in der Regel zu teuer)
		\end{itemize}
	\end{itemize}
	\item \textbf{Mip-Mapping}
	\begin{itemize}
		\item Einfache Vorfilterung von Texturen (Auflösungspyramide)
		\item Rekursive Speicherung von Texturen mit \(\frac{1}{4}\) Größe
		\item Meist Mittelung über je \(2~x~2\) Texel
		\item Insgesamt nur 33\% mehr Speicherbedarf
		\item Wahl der Mip-Map Stufe \(n\): \(Texelgroesse(n) \leq Groesse~Pixelfootprint~auf~Textur < Texelgroesse(n+1)\)
	\end{itemize}
	\item \textbf{Anisotrope Texturfilterung}
	\begin{itemize}
		\item Map-Mapping resultiert oft in sehr verschwaschenen Details
		\item Der Abdruck eines Pixels im Texturraum ist oft eher länglich
		\item RIPmaps (Rectangular MipMaps, in der Praxis selten): Rechteckige Vorfilterung entlang jeder Achse
		\item Vierfacher Speicherbedarf
	\end{itemize}
\end{itemize}

\subsubsection{Bestimmung des Footprints}
\begin{enumerate}
	\item Schicke einen Primärstrahl durch die Ecken eines Pixels
	\item Bestimme die vier Texturkoordinaten
	\item Differenzen der Texturkoordinaten liefern die Größe des Footprints
	\item Textur-Lookup an der berechneten Stelle mit der entsprechenden Filterung
\end{enumerate}

\subsubsection{Multitexturing}
\begin{itemize}
	\item Komplexe optische Effekte durch Kombination mehrerer Texturen
	\item Texturen enthalten oft auch andere Informationen, nicht nur Farbe
\end{itemize}


\subsection{Texturierungstechniken}
\begin{itemize}
	\item \textbf{Diffuse Textur}
	\begin{itemize}
		\item Kontrolle der Eigenfarbe eines Materials
		\item Bsp. Phong-Beleuchtungsmodell: \(k_d\) entstammt der Textur
	\end{itemize}
	\item \textbf{Bump oder Normal Mapping}
	\begin{itemize}
		\item Variation der Normalen einer Oberfläche durch Verwendung einer \textit{Bump Map} oder \textit{Displacement Map}
		\item Die Fläche bleibt geometrisch flach, nur die Normalen verändern sich
		\item Berechnung meist im Tangentenraum
	\end{itemize}
	\item \textbf{Gloss Map/Gloss-Textur}
	\begin{itemize}
		\item Kontrolle der Stärke und Streuung der spekularen Reflexion
		\item Bsp. Phong-Beleuchtungsmodell: \(k_s\) und \(n\) aus der Textur
	\end{itemize}
	\item \textbf{Displacement Mapping}
	\begin{itemize}
		\item Verschiebung der Oberfläche und Änderung der Normalen
		\item Keine reine Änderung der Beleuchtungsberechnung
		\item Bsp. Geometrie-Tesselierung und Verschiebung mit GPU-Unterstützung
	\end{itemize}
	\item \textbf{Inverse Displacement Mapping}
	\begin{itemize}
		\item Besonders schnelle Approximation, beispielsweise geeignet um Bodendetails darzustellen (Silhouetten meist problematisch)
		\item Geometrie wird nicht wirklich erzeugt, Schnittpunktberechnung wird im Texturraum durchgeführt
	\end{itemize}
	\item \textbf{Ambient Occlusion}
	\begin{itemize}
		\item Kontrolle des ambienten Anteils des Beleuchtungsmodells
		\item \(k_a\) entstammt der Textur, meistens wird auch der diffuse Term modifiziert
	\end{itemize}
	\item \textbf{Textur-Atlas}
	\begin{itemize}
		\item Spezielle Bijektive Parametrisierung: Jedem Oberflächenpunkt entspricht eine Stelle in der Textur
		\item Erstellung aufwendig per Hand oder automatisch
		\item Anwendungen
		\begin{itemize}
			\item Speichern einer Funktion/Daten auf der Oberfläche
			\item Erstellen der Textur direkt aus dem Objekt
			\item Berechnung von Normal-Maps aus fein aufgelösten Dreiecksnetzen
		\end{itemize}
	\end{itemize}
\end{itemize}


\subsection{Transparenz und Alpha-Test}
\begin{itemize}
	\item Rasterbilder werden oft mit 32 Bit/Pixel gespeichert (zusätzlicher 8 Bit Alpha-Kanal)
	\item (Semi-)Transparenz: Verwende Alpha-Kanal um die Transparenz der Oberfläche an einem Punkt zu bestimmen
	\item Alpha-Test: Verwerfe Objekt-/Schnittpunkt, wenn \(\alpha < threshold\)
\end{itemize}


\subsection{3D-Texturen für Oberflächen}
\begin{itemize}
	\item Probleme von 2D-Texturen: Tapeteneffekt, Verzerrung bei großer Flächenkrümmung
	\item \textbf{Solid-Texturen}
	\begin{itemize}
		\item "`Herausschneiden einer Skulptur"', z.B. aus einem Holz- oder Mamorblock
		\item Vorteil: Parametrisierung fällt weg
		\item Nachteil: Großer Speicherbedarf der Textur
		\item Erstellung sehr aufwendig
	\end{itemize}
	\item Solid-Textures: Prozedurales Erzeugen von 3D-Texturen
\end{itemize}


\subsection{Reflection/Environment-Mapping}
\begin{itemize}
	\item Darstellung reflektierender Objekte mit Spiegelung
	\item Approximation der Reflexion ohne Ray Tracing
	\item Idee: Speichern eines Bilds der Umgebung in einer Textur
	\item Entspricht anschaulich einer Textur auf einer virtuellen Kugel um ein Objekt/die Szene
	\item \textbf{Parametrisierungen}
	\begin{itemize}
		\item Latidute/Longtitude-Maps: Parametrisierung über Winkel, allerdings vergleichweise teuer in der Berechnung und ungleichmäßige Abtastung an den Polen
		\item Sphere-Mapping
		\begin{itemize}
			\item Speicherung ebenfalls in 2D-Textur
			\item Aufnahme soll mit einem Fotoapperat möglich sein
			\item Idealisierte Annahme: Bei der Aufnahme sollen alle Primärstrahlen parallel sein (kleine Spiegelkugel wird mit einem Teleobjekt fotografiert)
			\item Probleme
			\begin{itemize}
				\item Abtastrate maximal für Richtung entgegen der Aufnahmerichtung
				\item Singularität in Aufnahmerichtung (am Rand)
				\item Ungleiche Abtastung
			\end{itemize}
		\end{itemize}
		\item Kubische Environment Maps
		\begin{itemize}
			\item Abbilden der Umgebung auf einen Würfel
			\item Texturfilterung wie bei Mip-Mapping möglich
		\end{itemize}
	\end{itemize}
	\item \textbf{Aufnahme von Environment-Maps}
	\begin{itemize}
		\item In der Praxis: Meist mit spiegelden Chromkugeln
		\item Mehrere Aufnahmen zum nachträglichen Entfernen des Fotoapparats (HDR-Fotografie)
		\item Umrechnung in andere Parametrisierungen möglich
	\end{itemize}
	\item \textbf{Vorfilterung}
	\begin{itemize}
		\item Statt mehrfachem Abtasten wird die Textur vorgefiltert
		\item Größe und Form des richtigen Winkelbereichs abhängig von Material und parametrisierung
	\end{itemize}
\end{itemize}



\section{Räumliche Datenstrukturen}

\subsubsection{Optimierung des Ray Tracings}
\begin{itemize}
	\item Der wesentliche Rechenanteil des Ray Tracings entsteht durch das Finden von Schnittpunkten (ca. 90\%, skaliert schlecht)
	\item \textbf{Optimierungsansätze}
	\begin{itemize}
		\item Schnellerer Schnittalgorithmen? Wenig Spielraum zur Optimierung
		\item Weniger Strahlen: Verlust von Details; Unschärfen
		\item Weniger Schnittberechnungen: Vermeidung von Berechnung bei weit entfernten Objekten
		\item Schnittpunkte mit "`dicken"' Strahlen (nicht Teil der Vorlesung)
		\item Einführung von Datenstrukturen zur Raumunterteilung
	\end{itemize}
\end{itemize}


\subsection{Raumunterteilung}

\subsubsection{Idee/Ziel}
\begin{itemize}
	\item Finde potentiell geschnittene Objekte schneller
	\item Teste keine Objekte, die nicht in Frage kommen
\end{itemize}


\subsection{Hüllkörper}
\begin{itemize}
	\item Reduziert Schnitttest: Prüfe, ob ein Schnitt mit einer Umgebungsgeometrie ("`Hüllkörper"') existiert \(\rightarrow\) schneller Ausschluss des Schnitttests
	\item Hüllkörper möglichst enganliegend
	\item Lohnen nur, wenn die Geometrie entsprechend detailliert ist
\end{itemize}

\subsubsection{Axis Aligned Bounding Box}
\begin{itemize}
	\item Sechs orthogonale Ebenen, die das Objekt umschließen
	\item Bestimme nahsten Schnittpunkt \textit{innerhalb} der Box
	\item \textbf{Optimierungen}
	\begin{itemize}
		\item Mehrere Strahlen parallel
		\item Hierarchien von Bounding Boxes
	\end{itemize}
\end{itemize}

\subsection{Bounding-Volume-Hierarchie}
\begin{itemize}
	\item Idee: Hierarchie von einschließenden Hüllkörpern, automatisches Zusammenfassen von Objekten und Gruppen von Objekten
	\item Vorteile: Adaptivität der Raumunterteilung; schnellere Suche, da Objektgruppen ausgeschlossen werden können
	\item \textbf{Aufbau der Hierarchie}
	\begin{enumerate}
		\item Bestimme die gemeinsame Bounding Box aller Objekte
		\item Teile die Objekte in zwei Gruppen auf
		\item Verfahre so rekursiv weiter
	\end{enumerate}
	\item Schnittberechnung: Überprüfe auf Schnitt mit der Wurzel und steige rekursiv ab. Prüfe anschließend die weiter entfernten Knoten
	\item Problem: Bei überlappenden Hüllkörpern können mehrere Schnittpunkte hintereinander entstehen
	\item \textbf{Fazit}
	\begin{itemize}
		\item Vorteile
		\begin{itemize}
			\item Konstruktion und Traversierung ist einfach
			\item Resultiert in einem Binärbaum: Fixe, geringe Verzweigung
			\item Komplixität: Im Mittel \(\mathcal{O}(log~n)\) Schnitttests statt \(\mathcal{O}(n)\)
		\end{itemize}
		\item Herausforderungen
		\begin{itemize}
			\item Finden einer guten Unterteilung ist schwierig
			\item Ungeschickte Unterteilung kann zu schlechter Aufteilung führen
		\end{itemize}
	\end{itemize}
	\item Performance: Beschleunigung 2200x (Aufbau nicht berücksichtigt)
\end{itemize}


\subsection{Regulär Gitter}
\begin{itemize}
	\item \textbf{Vorgehen}
	\begin{enumerate}
		\item Unterteilung des Raums in Zellen gleicher Forum und Größe
		\item Eintrag der Objekte in Zellen, die von ihnen geschnitten werden
		\item Traversierung der vom Strahl getroffenen Zellen
		\item Schnittberechnung mit den enthaltenen Objekten
	\end{enumerate}
	\item Vermeidung mehrfacher Schnitttests: Markiere Objekt als getestet
	\item Mailboxing: Cache Schnitttests, die außerhalb der Zelle sind
	\item \textbf{Fazit}
	\begin{itemize}
		\item Vorteile
		\begin{itemize}
			\item Einfach zu konstruieren
			\item Einfach zu traversieren
		\end{itemize}
		\item Nachteile
		\begin{itemize}
			\item In der Regel mur wenige Zellen belegt
			\item Unter Umständen viel Geometrie in wenigen Zellen konzentriert
		\end{itemize}
	\end{itemize}
	\item Performance: Beschleunigung 2200x (Aufbau nicht berücksichtigt)
\end{itemize}


\subsection{Adaptive Gitter}
\begin{itemize}
	\item Idee: Rekursive Unterteilung einer Zelle bis
	\begin{itemize}
		\item sie nur noch eine vorgegebene Anzahl Primitive enthält, oder
		\item eine maximale Zahl an Unterteilungen durchgeführt wurde
	\end{itemize}
	\item \textbf{Oktalbaum (Octrees)}
	\begin{itemize}
		\item Aufbau
		\begin{enumerate}
			\item Beginne mit der Bounding Box für die ganze Szene
			\item Rekursive 1-zu-8 Unterteilung
		\end{enumerate}
		\item Adaptive Unterteilung erlaubt große Schritte im leeren Raum
		\item Feine Unterteilung dort (und nur dort) wo Geometrie ist
		\item Traversierung relativ teuer: Viele Auf- und Abbewegung in der Hierarchie
	\end{itemize}
	\item \textbf{Verschachtelte Gitter}
	\begin{itemize}
		\item Kombination aus regulären Gittern und Octrees
		\begin{itemize}
			\item Nutze effiziente Traversierung von regulären Gittern
			\item Nutze Adaptivität einer hierarchischen Repräsentation
		\end{itemize}
		\item Aufbau
		\begin{enumerate}
			\item Grobes Gitter für Bounding Box der Szene
			\item Bounding Box von Objekt/Primitiv/Gruppen mit dicht gepackten Objekten werden durch neues Gitter ersetzt
		\end{enumerate}
		\item Problem: Was sind gute Gruppen?
	\end{itemize}
\end{itemize}


\subsection{Baumstrukturen}

\subsubsection{BSP-Baum (Binary Space Partitioning Tree)}
\begin{itemize}
	\item Idee: Erweiterung von Binärbäumen auf \(k\) Dimensionen
	\item Verwende Ebenen um den Raum rekursiv zu unterteilen \(\rightarrow\) ergibt Binärbaumstruktur
	\item Die Unterteilungsebenen können beliebig orientiert sein
	\item \textbf{Konstruktion}
	\begin{enumerate}
		\item Initialisiere Wurzelknoten: Enthält alle Objekte der Szene
		\item Unterteile bis maximale Elementzahl pro Knoten oder maximale Rekursionstiefe erreicht ist
		\item Teile die Primitive in einen rechten und einen linken Kindknoten auf
	\end{enumerate}
	\item \textbf{Vergleich mit BHV}
	\begin{itemize}
		\item Echte Raumunterteilung: Knoten überlappen sich nicht
		\item Gute Anpassung an Geometrie möglich
		\item Blattknoten speichern die Primitive, Knoten speichern die Split-Ebenen
	\end{itemize}
\end{itemize}

\subsubsection{kD-Baum}
\begin{itemize}
	\item Split-Ebenen senkrecht zu den Achsen
	\item Primitive, die eine Split-Ebene schneiden werden meist in beide Kindknoten eingefügt
\end{itemize}


\subsection{Konstruktion "`guter"' kD-Bäume und BHV}

\subsubsection{Bestimmunf der optimalen Schnittebene}
\begin{itemize}
	\item Räumliches Mittel: Teile Knoten in der Mitte entlang der Achse mit der größten Ausdehnung oder in regelmäßiger Reihenfolge (Aufwand in \(\mathcal{O}(n~log~n)\))
	\item Objektmittel: So dass beide Kindknoten gleich viele Elemente enthalten (Aufbau in \(\mathcal{O}(n~log^2~n)\))
	\item Kostenfunktion: Im Mittel sollen zufällige Strahlen, die den betrachteten Knoten schneiden den gleichen Aufwand verursachen. Daraus resultiert ein balancierter Baum (Aufwand in \(\mathcal{O}(n~log^2~n\))
\end{itemize}

\subsubsection{Surface Area Heuristic (Kostenfunktion)}
\begin{itemize}
	\item Idee: Stelle eine Kostenfunktion auf und minimiere
	\item Unterteilung nur dann, wenn die Kosten dadurch geringer werden, als den Schnitt mit allen Objekten des Knotens zu berechnen
	\item Einsetzbar für BSP-Bäume, kD-Bäume und BHVs
	\item Kostenoptimierte Unterteilung: Isolation von komplexen Szenenteilen mit großen dünnbesetzten/leeren Bereichen
	\item \textbf{Unterteilung/Bestimmung der Unterteilung}
	\begin{itemize}
		\item Aufwendig, da der Suchraum groß sein kann
		\item Daher meist approximierte Konstruktion
		\item Gut konstruierte Bäume bzw. BHVs können um ein Vielfaches schneller sein als schlecht optimierte
	\end{itemize}
\end{itemize}

\subsubsection{Richtungsunterteilung}
\begin{itemize}
	\item Idee: Unterteile Objekte nach der Richtung, in der sie liegen
	\item Optional: Jeweils nach Entfernung
	\item Beschleunigen beispielsweise Schattentests bei Punktlichtquellen
	\item Werden sehr selten eingesetzt
\end{itemize}

\subsubsection{Modernes Ray Tracing: SIMD-Optimierung}
\begin{itemize}
	\item Kohärente Strahlenpakete: Gruppen von Strahlen mit ähnlichem Ursprung und Richtung
	\item Können oft sehr schnell verarbeitet werden
\end{itemize}



\section{Rasterisierung, Clipping und Projektionstransformation}
Interaktive/Echtzeitgrafik basiert meist auf Rasterisierung
\begin{itemize}
	\item Repräsentation von Oberflächen meist durch Dreiecke
	\item Abbilden der Dreiecke auf 2D Bildschirmkoordinaten
	\item Rasterisierung der Dreicke
	\item Interpolation von Farben, Texturkoordinaten, Tiefenwert, etc
	\item Verdeckungsberechnung, Tiefentest
\end{itemize}


\subsection{Tiefenpuffer}
\begin{itemize}
	\item Idee: Speichere für jeden Pixel die Distanz zur nahsten Fläche
	\item Entfernung/Tiefenwert wird pro Vertex berechnet und interpoliert
	\item Zusätzlich zum Framebuffer gibt es einen Z-Buffer
	\item \textbf{Nachteile}
	\begin{itemize}
		\item Speicherbedarf (heutzutage nicht mehr)
		\item Begrenzte Genauigkeit
		\item Transparente Flächen können nicht behandelt werden
		\item Viel unnötiger Aufwand in Szenen mit hoher Tiefenkomplexität
	\end{itemize}
	\item \textbf{Vorteile}
	\begin{itemize}
		\item Dreiecke können in beliebiger Reihenfolge verarbeitet werden (wichtig für Grafikhardware)
		\item Z-Buffering ist Standard in allen Rasterisierern
		\item Für die meisten Probleme existieren heute spezielle Lösungen oder Render-Techniken
	\end{itemize}
\end{itemize}


\subsection{Clipping}
\begin{itemize}
	\item Abschneiden von Linien/Polygon-Teilen, die außerhalb des Bildschirms liegen
	\item Wichtig für die Effiziens, die Rasterisierung und beispielsweise auch für Constructive Solid Geometry
	\item Ansätze: On-the-fly während der Rasterisierung oder besser analytisch
\end{itemize}

\subsubsection{Clipping von Polygonen}
\begin{itemize}
	\item Naives Clipping: Brute-Force (Teste nur Pixel am Bildschirm) oder Scanline (zeichne nur Scanlines innerhalb des Bildes)
	\item \textbf{Sutherland-Hodgeman Polygon Clipping}
	\begin{itemize}
		\item Clipping gegen eine Kante nach der anderen
		\item Effizient: Nach jeder Kante erhält man ein geschlossenes Polygon; erlaubt Pipelining
	\end{itemize}
\end{itemize}


\subsection{Projektion}
Wir betrachten zwei Arten Projektionen:
\begin{itemize}
	\item Orthographische Kamera: Parallele Sichtstrahlen, senkrecht zur Bildebene
	\item Perspektifische Kamera: Sichtstrahlen ausgehend von einem Projektionszentrum
	\item Zusätzliches Koordinatensystem: Clip Kordinaten
\end{itemize}


\section{Appendix A: Baryzentrische Koordinaten}
Baryzentrische Koordinaten dienen in der linearen Algebra und in der Geometrie dazu, die Lage von Punkten in Bezug auf eine gegebene Strecke, ein gegebenes Dreieck, ein gegebenes Tetraeder oder allgemeiner ein gegebenes Simplex zu beschreiben. Der Punkt wird dargestellt durch die Koeffizienten einer Affinkombination (also einer Linearkombination von Punkten, bei der die Summe der Koeffizienten 1 ist).\footnote{\url{http://de.wikipedia.org/wiki/Baryzentrische_Koordinaten}}

\subsection{Anwendungen}

\subsubsection{Liegt ein Punkt innerhalb eines Dreiecks?}
Der Punkt \(Q = \lambda_1 P_1 + \lambda_2 P_2 + \lambda_3 P_3\) liegt innerhalb des Dreiecks \(\triangle(P_1,P_2,P_3)\), wenn \(\lambda_1,\lambda_2,\lambda_3\) positiv sind.

\subsubsection{Lineare Interpolation von Farbwerten}
\begin{itemize}
	\item \textbf{Gegeben:} Eine Farbe \(c_1,c_2,c_3\) als RGB-Triple zu jedem Eckpunkt.
	\item \textbf{Gesucht:} Die interpolierte Farbe \(c_Q\) an einem Punkt \(Q\) auf dem Dreieck
	\item \textbf{Lösung:} Berechne \(\lambda_1,\lambda_2,\lambda_3\), dann ist \(c_Q=\lambda_1 c_1+\lambda_2 c_2 + \lambda_3 C_3\)
\end{itemize}

\subsubsection{Berechnung des Schnittpunkts eines Dreiecks und einer Geraden}
\begin{enumerate}
	\item \(r(t) = e+t\cdot d\), \(|d|=1\)
	\item Gleichsetzen
	\begin{itemize}
		\item \(r(t) = Q(\lambda_2,\lambda_3)\)
		\item \(e+t\cdot d = P_1+\lambda_2(P_2-P_1)+\lambda_3(P_3-P_1)\)
		\item Schnittpunkt, wenn \(\lambda_2+\lambda_3<1 \wedge \lambda_2 > 0 \wedge \lambda_3 >0\)
	\end{itemize}
	\item 3 Gleichungen mit 3 Unbekannten: \(e_x+t\cdot d_x=P_{1,x}+\lambda_2(P_{2,x}-P_{1,x})+\lambda_3(P_{3,x}-P_{1,x},...\)
	\item Lösung mittels Cramerscher Regel
	\begin{itemize}
		\item Baryzentrische Koordinaten müssen noch auf Positivität getestet werden
		\item Direkte Umsetzung im Programmcode
		\item Effizient, ohne Umweg über Ebenengleichung
	\end{itemize}
\end{enumerate}



\section{Appendix B: Transformationen}

\subsection{2D Transformationen}

\subsubsection{Skalierung}
\[scale(s_x,s_y) = \begin{pmatrix} s_x & 0 \\ 0 & s_y \end{pmatrix}\]

\subsubsection{Scherung horizontal}
\[shear_x(s) = \begin{pmatrix} 1 & s \\ 0 & 1 \end{pmatrix}\]

\subsubsection{Scherung vertikal}
\[shear_y(s) = \begin{pmatrix} 1 & 0 \\ s & 1 \end{pmatrix}\]

\subsubsection{Spiegelung}
\[\begin{pmatrix} -1 & 0 \\ 0 & 1 \end{pmatrix}~bzw.~\begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}\]

\subsubsection{Rotation}
\[rotate(\phi) = \begin{pmatrix} cos\phi & -sin\phi \\ sin\phi & cos\phi \end{pmatrix}\]


\subsection{3D Transformationen}

\subsubsection{Rotation}
\[R_x(\phi) = \begin{pmatrix} 1 & 0 & 0 \\ 0 & cos\phi & -sin\phi \\ 0 & sin\phi & cos\phi \end{pmatrix}\]
\[R_y(\phi) = \begin{pmatrix} cos\phi & 0 & sin\phi \\ 0 & 1 & 0 \\ -sin\phi & 0 & cos\phi \end{pmatrix}\]
\[R_z(\phi) = \begin{pmatrix} cos\phi & -sin\phi & 0 \\ sin\phi & cos\phi & 0 \\ 0 & 0 & 1 \end{pmatrix}\]
