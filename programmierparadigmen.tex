\chapter{Programmierparadigmen}

Zusammenfassung der Vorlesung "`Programmierparadigmen"' aus dem Wintersemester 2014.\footnote{\url{https://pp.info.uni-karlsruhe.de/lehre/WS201415/paradigmen/}}

\section{Funktionale Programmierung}

\subsection{Rekursion}
\begin{itemize}
	\item Auswertung: Zwischenausdrücke können mit Eingabegröße wachsen
	\item Speicherverbrauch in \(\mathcal{O}(n)\) bei \(\mathcal{O}(n)\) Aufrufen
	\item \textbf{Akkumulation}
	\begin{itemize}
		\item Übergebe Zwischenergebnisse in Hilfsparameter \texttt{acc}
		\item Speicherverbrauch in \(\mathcal{O}(1)\) bei \(\mathcal{O}(n)\) Aufrufen
	\end{itemize}
\end{itemize}

\subsubsection{Endrekursion}
\begin{itemize}
	\item Linearität: Eine Funktion heißt \textit{linear rekursiv}, wenn in jedem Defitionszweig nur ein rekursiver Aufruf vorkommt.
	\item Endrekursion: Eine linear rekursive Funktion heißt \textit{endrekursiv}, wenn in jedem Zweig der rekursive Aufruf nicht in andere Aufrufe eingebettet ist.
\end{itemize}


\subsection{Listen}
\begin{itemize}
	\item Eine Liste \texttt{(x:xs)} besteht immer aus Listenkopf \texttt{x} und Listenrest \texttt{xs}
\end{itemize}

\subsubsection{Pattern Matching}
\begin{itemize}
	\item Mehrere Gleichungen zur Definition einer Funktion
	\item Jede Gleichung gilt für Argumente mit speziellem Strukturmuster
	\item Überlappende Muster: Erste Gleichung wird angewandt
\end{itemize}


\subsection{Funktionen höherer Ordnung}

\subsubsection{Lambda-Notation}
\begin{itemize}
	\item Anonyme Funktionen und Funktionen höherer Ordnung möglich
	\item Beispiel: \(g(x,y)=x-\frac{y}{2} \longrightarrow\) \texttt{g = \textbackslash x y -> x - 2/y}
\end{itemize}

\subsubsection{Definition: Funktion höherer Ordnung}
Funktionen, die andere Funktionen als Parameter erhalten oder Funktionen als Rückgabewerte liefern, heißen Funktionen höherer Ordnung.

\subsubsection{Currying}
\begin{itemize}
	\item Ersetzung einer mehrstelligen Funktion durch Schachtelung einstelliger Funktionen.
	\item Jede Funktion erhält, wie oben erwähnt, nur ein Argument. Werden scheinbar mehrere Argumente definiert, so steckt immer Currying dahinter.
	\item Unterversorgung: Anwendung mehrstelliger Funktionen auf zu wenig Parameter
\end{itemize}

\textbf{Beispiel\footnote{\url{https://de.wikipedia.org/wiki/Currying\#Haskell}}}

\begin{lstlisting}[frame=single,numbers=left,mathescape,language=Haskell]
addiere x y = x + y
addiere 1 3                -- ist aequivalent zu (addiere 1) 3
addiereZu2  = addiere 2
addiereZu2 1               -- 3
\end{lstlisting}

\subsubsection{Namensbindung}
\begin{itemize}
	\item Bindungsstrukte legen Bedeutung und Geltungsbereiche von Variablen fest
	\item Verdeckung: Innere Bindungen verdecken äußere
	\item \textbf{Bindung}
	\begin{itemize}
		\item \texttt{f x = x*x}: Bindung von \texttt{x} im Rumpf von \texttt{f}, globale Bindung von \texttt{f}
		\item \texttt{\textbackslash x -> x*x}: Bindung von \texttt{x} innerhalb des \(\lambda\)-Ausdrucks
	\end{itemize}
\end{itemize}

\subsubsection{Lokale Bindung}
\begin{itemize}
	\item Anwendung: Lokale Hilfsfunktionen
	\item \texttt{let} bindet stärker als \texttt{where}
\end{itemize}

\textbf{Beispielse}

\begin{lstlisting}[frame=single,numbers=left,mathescape,language=Haskell]
energy m = let c = 299792458
           in m * c * c

energy m = m * c * c
  where c = 299792458
\end{lstlisting}

\subsection{Kombinatoren}

\subsubsection{Folds}
\begin{itemize}
	\item Anwendung einer Operation und eines Initialwertes auf eine Liste
	\item \textbf{Beispiel Summenberechnung}
	\begin{itemize}
		\item \texttt{sum = (+) 0}
		\item Berechnung mittels \texttt{foldr}: \texttt{(1 + (2 + (3 + (4 + 0))))} (rechts-geklammert)
		\item Berechnung mittels \texttt{foldl}: \texttt{((((1 + 0) + 2) + 3) + 4)} (links-geklammert)
	\end{itemize}
	\item Anwendung: Koplexe Funktionen als Kombination einfacher Funktionen
\end{itemize}

\subsubsection{Kombination von Listen}
\begin{itemize}
	\item Zusammenfügen von Listen per Reißverschluss: \texttt{zip = zipWith (,)}
	\item \texttt{zipWith} definiert eine Zusätzliche Operation
	\item Bricht ab, wenn eine der Listen keine weiteren Elemente enthält
\end{itemize}

\subsubsection{List Comprehensions}
\begin{itemize}
	\item Automatisiertes Erzeugen von Listen, basierend auf bereits existierenden Listen
	\item Inspiriert durch die mathematische Mengenschreibweise: \texttt{s = {[} 2 * x {|} x <- {[}0..{]}, x\textasciicircum 2 > 3 {]} } \footnote{\url{https://en.wikipedia.org/wiki/List_comprehension\#Haskell}}
	\item Multidimensionale Liste: \texttt{s = {[} 2*x*y {|} x <- {[}0..{]}, x\textasciicircum2 > 3, y <- {[}1,3..x{]}, y\textasciicircum2 < 100-x\textasciicircum2 {]}}
\end{itemize}


\subsection{Lazy Evaluation}

\subsubsection{Auswertung}
\begin{itemize}
	\item Struturierte Daten: Nur auswerten, falls wirklich benötigt wird
	\item Duplizierte Argumente: Auswertung maximal einmal (\textit{sharing})
	\item Pattern-Matching: So weit wie nötig, bis passendes Muster gematched
	\item Boolsche Operatoren: Auswertung bis zum ersten \textit{false} (\textit{short-circuit-Auswertung})
	\item \textbf{Nachteile}
	\begin{itemize}
		\item Erschwerte Fehlersuche
		\item Fehler, die beim Testen nicht beachten wurden, tauchen eventuell später im Betrieb auf
	\end{itemize}
\end{itemize}


\subsection{Typen}
\begin{itemize}
	\item Haskell ist statisch typisiert
	\item Jeder gültige Ausdruck hat immer einen Typ und wertet immer zu gültigen Werten dieses Typs aus
	\item Schreibweise: \texttt{e :: t} falls Ausdruck \texttt{e} und Typ \texttt{t}
	\item Untypisierbare Ausdrücke erzeugen Übersetzerfehler
	\item Haskell erkennt den korrekten Typ (fast immer) zuverlässig, optional manuelle Deklaration möglich
\end{itemize}

\subsubsection{Polymorphe Typen}
\begin{itemize}
	\item Der Listen-Typ sind polymorph, die Typvariable \texttt{{[}t{]}} steht auch für Nicht-Basistypen
	\item Typvariablen parametrisieren polymorphe Typen
	\item Typkonstruktoren wie \texttt{{[} {]}} erzeugen neue Typen aus bestehenden
	\item \textbf{Funktionstypen}
	\item Funktionstypen sind ebenfalls polymorph
\end{itemize}

\subsubsection{Beispiele}
\begin{itemize}
	\item Typen mehrstelliger Funktionen: \texttt{f x y = x * y, f :: Integer -> Integer -> Integer}
	\item Typen eingebauter Operatoren: \texttt{(<=) :: Integer -> Integer -> Bool}
	\item Tupel: \texttt{(3, True) :: (Integer, Bool); (not, 7) :: (Bool -> Bool, Integer)}
\end{itemize}

\subsubsection{Typinferenz}
Errechnen der Typen durch den Compiler, dadurch entstehen kompakte Programme, die trotzdem typsicher sind. Manuelle Deklaration ist dennoch möglich.

\subsubsection{Typsynonyme}
Ableiten neuer Typen aus vorhandenen. Z.B. \texttt{type String = {[}char{]}} (kann die Lesbarkeit erhöhen). Es werden keine explizit neuen Typen erzeugt.

\subsubsection{Typen bei der Fehlersuche}
\begin{itemize}
	\item Typendeklarationen können beim Lokalisieren von Programmfehlern helfen
	\item Beabsichtigten Typ der Funktion deklarieren
	\item \textbf{Beispiel}
	\begin{itemize}
		\item \texttt{isDigit :: Char -> Bool}\\\texttt{isDigit c = isIn c "0123456789"}
		\item \texttt{*Main> isDigit '3'} würde zu einem Typfehler führen
	\end{itemize}
\end{itemize}

\subsubsection{Mengen}
\begin{itemize}
	\item Mengen bestehen aus dem Typ \texttt{Set = ...} sowie Funktionen zum Iterieren, Einfügen, Löschen, Vergleichen, usw.
	\item Einfachste Implementierung als Listen: \texttt{type Set t = {[} {]}}
\end{itemize}


\subsection{Algebraische und rekursive Datentypen}

\subsubsection{Nachteile von Tupeln}
\begin{itemize}
	\item Produkttypen: Typen mit mehreren Komponenten. Beispiel: Personen mit Name und Alter \texttt{type Person = (String, Int)}
	\item Nachteil: Bedeutung von Werten nicht explizit; ungewollte Verwendung beliebiger \texttt{(String, Int)} Tupel
\end{itemize}

\subsubsection{Algebraische Datentypen}
\begin{itemize}
	\item Verwendung des Schlüsselwortes \texttt{data} statt \texttt{type} zur definition \textit{neuer} Typen
	\item Mehrere Konstruktoren möglich
\end{itemize}

\subsection{Anwendung algebraischer Datentypen}
\begin{itemize}
	\item \textbf{Algebraischer Datenstrukturen ermöglichen}
	\begin{itemize}
		\item Implementierung von Datenstrukturen
		\item Modellierung problemspezifischer Daten
	\end{itemize}
	\item \textbf{Einsatz von Pattern-Matching}
	\begin{itemize}
		\item Erleichtert Umsetzung komplexer Algorithmen
		\item Besonders für baumartige Strukturen
	\end{itemize}
	\item \textbf{Anwendungsbeispiele}
	\begin{itemize}
		\item Datenstrukturen: Maps, Bäume, Rot-Schwarz-Bäume
		\item Fehlerbehandlung
		\item Termersetzungssysteme
	\end{itemize}
\end{itemize}



\section{Theoretische Grundlagen}
Kalküle sind minimalistische Programmiersprachen zur Beschreibung von Berechnungen.	

\subsection{Der untypisierte $\lambda$-Kalkül}
\begin{itemize}
	\item Turing-mächtiges Modell funktionaler Programme zur Beschreibung sqeuentieller imperativer Konstrukte
	\item Linkassoziative Funktionsanwendung
	\item \(\lambda\)-Term: Ein Term der Form \texttt{(\(\lambda\)x.\(t_1\))\(t_2\)}
	\item \textbf{\(\alpha\)-Äquivalenz}
	\begin{itemize}
		\item \(t_1\) und \(t_2\) heißen \(\alpha\)-äquivalent, wenn \(t_1\) in \(t_2\) durch konsistente Umbenennung der \(\lambda\)-gebundenen Variablen überführt werden kann
		\item Funktionsbezeichnungen dürfen nicht geändert werden
		\item Beispiel: \texttt{\(\lambda\)x. (\(\lambda\)z. f(\(\lambda\)y. z y) x) = \(\lambda\)y. (\(\lambda\)x. f(\(\lambda\)z. x z) y)}
	\end{itemize}
	\item \textbf{\(\eta\)-Äquivalenz}
	\begin{itemize}
		\item Zwei Funktionen genau dann gleich sind, wenn sie für alle Argumente dasselbe Resultat liefern\footnote{\url{https://de.wikipedia.org/wiki/Lambda-Kalkül\#.CE.B7-Konversion}}
		\item Terme \texttt{\(\lambda\)x. f x} und \texttt{f} heißen \(\eta\)-äquivalent, falls \texttt{x} eine nicht-freie Variable von \texttt{f} ist
	\end{itemize}
\end{itemize}

\subsubsection{$\beta$-Reduktion}
\begin{itemize}
	\item Formalisiert das Konzept der Funktionsanwendung
	\item Anwendung ausschlißelich von links nach rechts
	\item Eine \(\beta\)-Reduktion entspricht der Ausführung der Funktionsanwendung auf einem Redex: \texttt{(\(\lambda\)x.\(t_1\))\(t_2 \Rightarrow\) \(t_1\){[} x \(\mapsto t_2\) {]}}
	\item Volle \(\beta\)-Reduktion: Jeder Redex kann reduziert werden
	\item \textbf{Beispiele}
	\begin{itemize}
		\item \texttt{(\(\lambda\)x.x)y \(\Rightarrow\) x{[} x \(\mapsto\) y {]} = y}
		\item \texttt{(\(\lambda\)x.x (\(\lambda\)x.x))(y z) \(\Rightarrow\) (x (\(\lambda\)x.x)){[} x \(\mapsto\) y z {]} = (y z)(\(\lambda\)x.x)}
	\end{itemize}
	\item \textbf{Kodierung mit Funktionen höherer Ordnung}
	\begin{itemize}
		\item Man braucht nicht unbedingt primitive Operationen
		\item Beispiel: \texttt{let}
		\item \texttt{let x = \(t_1\) in \(t_2\)} wird zu \texttt{(\(\lambda\)x.\(t_2\)) \(t_1\))}
		\item \texttt{let x = g y in f x = (\(\lambda\)x.f x)(g y) \(\Rightarrow\) f(g y)}
	\end{itemize}
\end{itemize}

\subsubsection{Kodierung natürlich Zahlen (Church-Zahlen)}
\begin{itemize}
	\item Einbettung von Daten und Operationen in den \(\lambda\)-Kalkül
	\item Eine (natürliche) Zahl drückt aus, wie oft die Funktion \texttt{s} angewendet wird
	\item \textbf{Church-Zahlen}
	\begin{itemize}
		\item \texttt{\(c_0\) = \(\lambda\)s. \(\lambda\)z. z}
		\item \texttt{\(c_1\) = \(\lambda\)s. \(\lambda\)z. s z}
		\item \texttt{\(c_2\) = \(\lambda\)s. \(\lambda\)z. s (s z)}
		\item \texttt{\(c_3\) = \(\lambda\)s. \(\lambda\)z. s (s (s z))} \\ \(\vdots\)
		\item \texttt{\(c_n\) = \(\lambda\)s. \(\lambda\)z. \(s^n\) z}
	\end{itemize}
\end{itemize}

\subsubsection{Rechnen mit Church-Zahlen}
\begin{itemize}
		\item Nachfolgerfunktion: \texttt{succ = \(\lambda\)n. \(\lambda\)s. \(\lambda\)z. s(n s z)} errechnet den Nachfolger. Beispielsweise ist \texttt{succ(\(c_2\)) = \(c_3\)}
		\item Addition: \texttt{plus = \(\lambda\)m. \(\lambda\)n. \(\lambda\)s. \(\lambda\)z. m s (n s z)}. Beispielsweise erreichnet \texttt{plus \(c_2\) \(c_3\) = \(c_5\)}
		\item Multiplikation: \texttt{times = \(\lambda\)m. \(\lambda\)n. \(\lambda\)s. n (m s)}.
		\item Potenzieren: \texttt{exp = \(\lambda\)m. \(\lambda\)n. n m}. Berechnung per Induktion über \texttt{n}
\end{itemize}

\subsubsection{Kodierung boolscher Werte}
\begin{itemize}
	\item \texttt{True} und \texttt{False} wird zu \texttt{\(c_{true}\) = \(\lambda\)t. \(\lambda\)f. t} und \texttt{\(c_{false}\) = \(\lambda\)t. \(\lambda\)f. f}
	\item \texttt{if \_ then \_ else \_} wird zu \texttt{\(\lambda\)a. a}. Beispielsweise wird aus \texttt{if True then x else y}: \texttt{(\(\lambda\)a. a) (\(\lambda\)t. \(\lambda\)f. t) x y \(\Rightarrow\) (\(\lambda\)t. \(\lambda\)f. t) x y \(\Rightarrow\) (\(\lambda\)f. x) y}
	\item \texttt{\(b_1\) \&\& \(b_2\)} wird zu \texttt{if \(b_1\) then \(b_2\) else False}
	\item \texttt{True \&\& True} ergibt: \texttt{\(\lambda\)a. a) \(c_{true}\) \(c_{true}\) (\(\lambda\)t. \(\lambda\)f. t)}
\end{itemize}

\subsubsection{Divergenz}
\begin{itemize}
	\item Terme, die nicht zu einer Normalform auswerten, divergieren
	\item Diese modellieren unendliche Ausführungen
\end{itemize}


\subsection{Typsysteme}
\begin{itemize}
	\item Typklassen definieren Funktionen, die für jede Instanz der Typklasse aufgerufen werden können
	\item Man kann eine Instanz für jeden Typ erstellen, indem man die Funktionen der Typklasse für den jeweiligen Typ definiert
	\item Beispiel: Vergleichsoperator (\texttt{==})
\end{itemize}

\subsubsection{Typen}
\begin{itemize}
	\item \textbf{Typen} legen die möglichen Werte von Variablen, Operationen und Operanden fest. Beispiel: Integer, Float, String
	\item \textbf{Statisch typisierte Sprachen:} Jede Variable/jeder Ausdruck hat einen vom Compiler bestimmbaren Typ. Beispiel: Java, Haskell, C++
	\item \textbf{Dynamisch typisierte Sprachen:} Typ von Variablen kann sich zur Laufzeit ändern. Beispiele: JavaScript, Python, PHP
\end{itemize}

\subsubsection{Typherleitung (F196)}
\begin{itemize}
	\item Nachweis von Herleitbarkeit als Herleitungsbaum
	\item Die Struktur des Herleitungsbaums wird durch den \(\lambda\)-Term bestimmt
	\item Zu jedem Subterm genau eine passende Regel: \texttt{App, Var, Abs oder Const}
	\item \texttt{t} ist typisierbar im Kontext \(\Gamma\), falls \(\tau\) mit \(\Gamma\vdash t_2~:~\tau_2\) exisitiert
	\item Beispiel auf Folie 196
\end{itemize}

\subsubsection{Untypisierbare \(\lambda\)-Terme (F197)}
\begin{itemize}
	\item Nicht alle sicheren Programme sind typisierbar \(\rightarrow\) Typsystem nicht vollständig bzgl. \(\beta\)-Reduktion
	\item Beispiel: \texttt{(\(\lambda\)x. x + 42) true} ist nicht typisierbar
	\item Die Korrektheit des Typsystems ist per Induktion über die Typsystemregeln beweisbar (F198)
\end{itemize}


\subsection{Polymorphie (F199)}
\begin{itemize}
	\item Polymorphe Funktionen: Verhalten hängt nicht vom konkreten Typ \(\tau\) der Elemente ab und haben unendlich viele Typen
	\item Beispiel: Operationen auf Containern (Zusammenfügen von Listen)
\end{itemize}

\subsubsection{\texttt{let}-Polymorphismus}
\begin{itemize}
	\item Beispielprogramm P: \texttt{let f = \(\lambda\)x. 2 in f(f true)}
	\item \texttt{f} ist eine polymorphe Hilfsfunktion: Anwendung erst auf \texttt{true}, dann auf \texttt{2}
	\item Kodierung: \texttt{let x = \(t_1\) in \(t_2\)} als neues Konstrukt im \(\lambda\)-Kalkül. Neue Typregeln mit \textit{Typschemata}
	\item \textbf{Typschemata (F202)}
	\begin{itemize}
		\item Ein Typ der Gestalt \(\forall\alpha_1.\forall\alpha_2.~...~\forall\alpha_n.~\tau\) heißt Typschema
		\item Es bindet freie Typvariablen \(alpha_1,...,\alpha_n\) in \(\tau\)
		\item Beispiel: \(\forall\alpha.~\alpha\rightarrow\alpha\) steht für unendlich viele Typen
	\end{itemize}
\end{itemize}


\section{Logische Programmierung}
Prolog-Programme bestehen aus einer Datenbasis, deren Einträge sich Fakten und Regeln nennen. Der Benutzer formuliert Anfragen an diese Datenbasis. Der Prolog-Interpreter benutzt die Fakten und Regeln, um systematisch eine Antwort zu finden. Ein positives Resultat bedeutet, dass die Anfrage logisch ableitbar ist. Ein negatives Resultat bedeutet nur, dass aufgrund der Datenbasis keine Ableitung gefunden werden kann.\footnote{\url{https://de.wikipedia.org/wiki/Prolog_(Programmiersprache)\#Grundprinzip}}

\subsection{Einführung in Prolog}
\begin{itemize}
	\item Situationsbeschreibung
	\item Definition von Objekten und Beziehungen zwischen Objekten
	\item Darstellbar als Terme einer freien Termalgebra
\end{itemize}

\subsubsection{Termsyntax}
\begin{itemize}
	\item Atome: z.B. \texttt{hans, inge, fritz, fisch}
	\item Zahlen: z.B. \texttt{3, 4.5}
	\item Variablen: z.B. \texttt{X, Y, \_X, X1, Fisch}
	\item Termlisten: z.B. \texttt{3, 4.5, X, fritz}
	\item Zusammengesetzt: z.B. \texttt{liebt(fritz,fisch), liebt(fritz,X)}
\end{itemize}

\subsubsection{Variablen}
Platzhalter für unbekannte Terme. Können auch "`Allgemeinheit"' ausdrücken, beispielsweise \texttt{liebt(X, fussball)} \(\rightarrow\) "`Alle lieben Fußball"'.

\subsubsection{Abfragen}
\begin{itemize}
	\item Alle Fakten werden zur Laufzeit in einer Datenbank gehalten
	\item Einleitung per \texttt{?}: z.B. \texttt{?liebt(fritz,fisch)}
	\item \textbf{Mehrfachlösungen}
	\begin{itemize}
		\item Durchsuche Datenbank von vorne nach hinten
		\item Versuche jeweils, Abfrageparameter mit Datenbankfaktor zu unifizieren
	\end{itemize}
	\item \textbf{Konjunktion von Abfragen}
	\begin{itemize}
		\item Konjunktion von Teilzielen getrennt durch Komma, entspricht logischem \(\wedge\)
		\item Erfülle Teilziele von links nach rechts und nehme jeweils erstes Ergebnis
		\item Mehrere Ergebnisse: Fahre mit dem ersten Ergebnis bis zum Ende fort, prüfe danach weitere Ergebnisse
		\item Nach Erfüllung eines Teilziels: Nächstes Teilziel erbt Instanziierung
	\end{itemize}
\end{itemize}

\subsubsection{Regeln}
\begin{itemize}
	\item Aufbau: Regelkopf (1 Term) und Regelrumpf (1+ Terme): \texttt{term :- termlist .}
	\item \texttt{:-} liest sich als \textit{wenn}, Kommata als \textit{und}
	\item \textbf{Beispiele}
	\begin{itemize}
		\item "`Wenn Inge X liebt und wenn X Fisch liebt, dann liebt Hugo X"':\newline\texttt{liebt(hugo,X) :- liebt(inge,X),liebt(X,fisch)}
		\item "`Wenn es jemanden gibt, der Fisch mag, dann liebt Emil Erna"':\newline\texttt{liebt(emil,erna) :- liebt(X,fisch)}
	\end{itemize}
\end{itemize}

\subsubsection{Logische Programmierung ist anders}
\begin{itemize}
	\item Keine herkömmlichen Variablen
	\item Prädikate liefern außer ihrer Erfüllbarkeit keinen Ergebniswert
	\item Aber Unifikation und Backtracking eingebaut
	\item Sehr gut geeignet für Such- und Constraintprobleme, weniger für Berechnungen
\end{itemize}


\subsection{Backtracking}
\begin{itemize}
	\item Visualisierung durch einen Ausführungsbaum
	\item Jedes Teilziel wird als Box mit vier Ein- bzw. Ausgängen dargestellt
\end{itemize}

\subsubsection{Der Algorithmus informell}
\begin{enumerate}
	\item Anlegen und erstmaliges Betreten der Box durch den \texttt{call}-Eingang beim ersten Aufruf des Teilziels
	\item Falls keine passende Regel gefunden wird, wird die Box durch den \texttt{fail}-Ausgang verlassen und gelöscht
	\item Für eine passende Regel werden Kind-Boxen für Teilziele im Regelrumpf angelegt. Die Box wird durch den \texttt{success}-Ausgang verlassen. Dieser verweist auf den \texttt{call}-Eingang der ersten Kindbox
	\item Falls keine Kinder existieren (Fakt), verweist \texttt{success} auf den \texttt{call}-Eingang des nächsten Teilziels
	\item Der \texttt{fail}-Ausgang verweist auf den \texttt{redo}-Eingang des vorherigen Teilziels
	\item Wird eine Box durch den \texttt{redo}-Eingang betreten, werden mit Hilfe des Choice Points weitere anwendbare Regeln gesucht. Falls kein Choice Point existiert, wird die Box durch \texttt{fail}
	\item Der \texttt{fail}-Ausgang der obersten/ersten Box erzeugt die Ausgabe \texttt{no}
	\item Der \texttt{success}-Ausgang der rechtest-untersten/letzten Box gib Substitution aus. Falls der Benutzer eine alternative Lösungen anfordert, wird die Box durch \texttt{redo} wieder betreten
\end{enumerate}


\subsection{Arithmetik und Listen}

\subsubsection{Listen: \texttt{{[}X{|}Y{]}}}
\begin{itemize}
	\item \texttt{X} ist das erste Element der Liste (\textit{head}), \texttt{Y} ist der Rest der Liste (\textit{tail}), \texttt{{[}{]}} bezeichnet die leere Liste
	\item \texttt{Y} muss nicht instanziiert sein
	\item \textbf{Listenfunktionen}
	\begin{itemize}
		\item \texttt{member}
		\begin{itemize}
			\item Berechnet, ob ein Element in der Liste vorkommt
			\item \texttt{member(X, {[}X{|}R{]}).} \\ \texttt{member(X, {[}X{|}R{]}) := member(X,R).}
		\end{itemize}
		\item \texttt{append}
		\begin{itemize}
			\item Fügt zwei Listen zusammen (Konkatenation)
			\item Wenn die Konkatenation von \texttt{R} und \texttt{L} die Liste \texttt{T} ergibt, dann ergibt die Konkatenation von \texttt{{[}X{|}R{]}} und \texttt{L} die Liste \texttt{{[}X{|}T{]}}.
			\item \texttt{append({[]}, L, L).} \\ \texttt{append({[}X{|}R{]}, L, {[}X{|}T{]}) :- append(R, L, T).}
			\item Beispiel: \texttt{?append({[}1, 2, 3, 4{]}, {[}2, 3, 4, 5{]}, X).} ergibt \texttt{X = {[}1, 2, 3, 4, 2, 3, 4, 5{]}}
		\end{itemize}
		\item \texttt{rev}
		\begin{itemize}
			\item Naiver Ansatz: Eine nichtleere Liste wird invertiert, in dem man rekursiv den Listenrest invertiert und jeweils die Listenköpfe davor hängt
			\item Ineffizient, da in jedem Schritt die neue Liste durchlaufen und kopiert werden muss, um ein neues Element anzuhängen
			\item Alternativ: Nutze Akkumulator zum Zwischenspeichern des Ergebnisses
		\end{itemize}
		\item \texttt{permute}
		\begin{itemize}
			\item Erzeugt alle möglichen Permutationen einer Liste
		\end{itemize}
	\end{itemize}
\end{itemize}

\subsubsection{Arithmetik}
\begin{itemize}
	\item Reines Prolog kann alle berechnebaren Funktionen verarbeiten, Prädikate werden über Atome dargestellt
	\item Zuweisung per Teilziel \texttt{is}
	\item Unterschied zur normalen Resolution: Variablen im \textit{rechten} Term müssen instanziiert sein \(\rightarrow\) nur vorwärts anwendbar
\end{itemize}

\subsubsection{Funktionen}
\begin{itemize}
	\item Funktionen in Prolog als Prädikate
	\item Prädikate tragen außer der Erfüllbarkeit keinen Rückgabewert \(\rightarrow\) Rückgabewert als zusätzliche Variable
	\item Formal ähnlich zum Pattern Matching
\end{itemize}

\subsubsection{Generate und Test}
TODO
\begin{itemize}
	\item \textbf{Prolog ist besonders gut}
	\begin{itemize}
		\item für systematisches Durchprobieren
		\item mittels mehrfach reerfüllbarer Prädikate
		\item erzeugen Lösungskandidaten, welche danach getestet werden
	\end{itemize}
\end{itemize}


\subsection{Der Cut}

\subsubsection{Determinismus}
Ein Prädikat heißt \textit{deterministisch}, wenn es stets auf höchstens eine Weise erfüllt werden kann; hat es möglicherweise mehrere Lösungen, so heißt es nichtdeterministisch.

In der nichtfunktionalen Welt kann Nichtdeterminismus nur behandelt werden, indem man von Lösungen zu Listen von Lösungen übergeht.

\subsubsection{Beschneiden des Ausführungsbaums}
\begin{itemize}
	\item Die Lösungsfindung kann vorzeitig durch den Programmierer abgebrochen werden ("`Cut"')
	\item Das Einfügen eines Cuts ("`\texttt{!}"') verhindert, dass im Fehlerfall, die Teilziele links davon nicht erneut aufgerufen werden
	\item Beispiel auf Folie 246
\end{itemize}

\subsubsection{Blaue, grüne und rote Cuts}
\begin{itemize}
	\item \textbf{Blauer Cut}
	\begin{itemize}
		\item Beeinflusst weder Programmlaufzeit noch -verhalten
	\end{itemize}
	\item \textbf{Grüner Cut}
	\begin{itemize}
		\item Beeinflusst Programmlaufzeit aber nicht -verhalten
		\item Schnellere Ausführung und weniger Speicherbedarf
		\item Beispiel: Einfügen in Funktionen, von denen man weiß, dass sie deterministisch sind
	\end{itemize}
	\item \textbf{Roter Cut}
	\begin{itemize}
		\item Beeinflusst das Programmverhalten
		\item Werden verwendet, um Wächter zu ersetzen. Ist der erste Wächter erfolgreich, wird der zweite nie angewendet
		\item Können zu erheblichem Effiziensgewinn führen, da sie u.U. sehr komplexe und teure Wächter ersetzen
	\end{itemize}
	\item Faustregel: Der Cut darf erst kommen, wenn man weiß, dass man in der rechtigen Regel ist, aber muss vor der Instanziierung der Ausgabevariablen stehen
	\item Negation: Ein Negationsprädikat ist in Prolog ohne (roten) Cut nicht ausdrückbar
\end{itemize}


\subsection{Unifikation und Resolution}


\subsection{Spracherweiterungen}


\subsection{Constraint Logic Programming}



\section{Typinferenz}

\subsection{Typinferenz: $\lambda$-Kalkül}


\subsection{Typinferenz: \textit{let}-Polymorphismus}



\section{Grundlagen der Prallelprogrammierung}
Motivation: Leistungssteigerung über steigende Taktfrequenzen hinaus.

\subsubsection{Programmieransätze gemäß der Computerarchitektur}
\begin{itemize}
	\item Gemeinsamer Speicher: Jeder Prozessor kann jede Speicherzelle ansprechen (z.B. Multikernrechner)
	\item Verteilter Speicher: Jeder Prozessor hat seinen eigenen Speicher, Kommunikation über \textit{Message Passing} (z.B. bei Computerclustern)
\end{itemize}
Bei sequentieller Programmierung arbeitet der Prozessor nacheinander einzelne Befehle aus dem Arbeitsspeicher ab (von-Neumann-Architektur).

Bei paralleler Programmierung wird in der Theorie häufig das \textit{PRAM-Modell} mit einer beliebigen Anzahl an Prozessoren mit
\begin{itemize}
	\item jeweils lokalem Speicher
	\item und synchronem Zugriff auf globalen, gemeinsam genutzten Speicher (in der Praxis eher problematisch bei der Umsetzung.
\end{itemize}

\subsubsection{Flynn's Taxonomy}
\begin{enumerate}
	\item \textit{Single Instruction x Single Data:} Klassische von-Neumann-Architektur, ein Befehlsstrom arbeitet auf dem Speicher
	\item \textit{Single Instruction x Multiple Data:} Ein Befehl wird auf gleichartige Daten (z.B. Arrays) angewendet, typischerweise in Vektorprozessoren früherer Supercomputers
	\item \textit{Multiple Instruction x Multiple Data:} Verschiedene Prozessoren arbeiten auf verschiedenen Daten, beispielsweise in heutigen Multicore-Maschinen
	\item \textit{Multiple Instruction x Single Data:} Mehrere Befehle werden gleichzeitig auf den gleichen Daten ausgeführt, beispielsweise in redundanten Architekturen oder in den Pipelines moderner Prozessoren (Ansicht ist umstritten)
\end{enumerate}

\subsubsection{Herausforderungen}
\begin{itemize}
	\item Bereits schrittweise Parallelität benötigt Synchronisation
	\item Kommunikation der Prozesse untereinander
	\item Wettlaufbedingungen und Verklemmungen
\end{itemize}
Idealerweise lassen sich Probleme für Parallelverarbeitung so zerlegen, dass sie ohne Abhängigkeiten berechnet werden können; auch stückweise Parallelisierung ist möglich.

\subsubsection{Mögliche Beschleunigung}
\begin{itemize}
	\item Speedup: \(S(p) = \frac{T(n,1)}{T(n,p)} = \frac{Anzahl~mit~einem~Prozessor}{Aufwand~mit~p~Prozessoren}\)
	\item Amdahls Gesetz berechnet die maximale Beschleunigung, die durch Parallelverarbeitung erreicht werden kann: \(\frac{1}{(1-P)+\frac{P}{N}}\)
\end{itemize}


\subsection{Fortgeschrittene Konzepte in Java}

\subsubsection{Multithreading in Java}
\begin{itemize}
	\item Threads vor Java oft eher schwierig zu implementieren (in C/C++ zusätzliche Bibliotheken notwendig)
	\item In Java bereits in der Sprache enthalten
	\item Nicht vorgegeben ist allerdings die interne Implementierung des Multithreading in der jeweiligen VM
	\item Erben von der Klasse \textit{Thread} oder implementieren des Interface \textit{Runnable}
	\item \(stop()\) mit Hilfe von Pollen realisiert; ein Thread, der nicht beendet werden will, kann von außen nicht "`sauber"' beendet werden
	\item Rückgabewerte über \(Thread.join()\) realisierbar oder durch die Verwendung von \(Callables\) oder \(Futures\)
\end{itemize}


\subsection{\textit{C/C++} Wiederholung}


\subsection{Message Passing Interface (MPI)}


\subsection{Scala}


\subsection{X10}



\section{Compiler}

\subsection{Einführung}
\begin{itemize}
	\item Reiner Übersetzer: Liest den Quelltext Anweisung für Anweisung; billig; sinnvoll bei Kommandasprachen (Unix-Shell)
	\item Interpretation nach Vorübersetzer: Transformation in eine günstigere Form; nicht unbedingt maschinennah; beispielsweise Java-Bytecode oder Python
	\item Vollständige Übersetzung: Übersetzung in Maschinencode,; Zielsprache beschreibt eine abstrakte Laufzeitmaschine, definiert durch Hardware, Betriebssystem, etc; beispielsweise C/C++ oder Fortran
	\item Just-in-time-Compiler: Übersetzung bedarfsgerecht während der Ausführung; beispielsweise die moderne JVM oder .NET
\end{itemize}


\subsection{Lexikalische Analyse}


\subsection{Syntaktische Analyse}


\subsection{Semantische Analyse}


\subsection{Java-Bytecode (S390)}
\begin{itemize}
	\item \textbf{Java-Technologie}
	\begin{itemize}
		\item Bytecode: Portable, plattformunabhängige Zwischensprache
		\item Als virtuelle Maschine mit Laufzeitsystem spezifiziert
		\item Umfangreiche Bibliothek
	\end{itemize}
	\item \textbf{Virtuelle Maschine - Laufzeitsystem (S392)}
	\begin{itemize}
		\item Heap: Speicher für Objektinstanzen, getypt, Garbage Collection, gemeinsamer Speicher für alle Threads
		\item Method Area: Code für Methoden (read-only)
		\item Runtime Constant Pool: Konstante Daten (Literale, Typinformationen, etc)
		\item Threads: Jeweils mit Program Counter, JVM Stack mit Activation Records (Rücksprungadresse, dynamischer Vorgänger, lokale Variablen, Operandenstack) und Native JVM Stack (Laufzeitsystem, meist in C/C++ geschrieben) 
	\end{itemize}
\end{itemize}

\subsubsection{Instruktionen (S395)}
\begin{itemize}
	\item Typen bekannt aus Java
	\item Instuktionen explizit typisiert: \texttt{iadd(int)}, \texttt{fadd(float)}
	\item Instruktionsklassen im Anhang
	\item Beispiel ab S396
\end{itemize}

\subsubsection{Methodenaufrufe (S398)}
Komplettes Beispiel mit Konstantenpool auf S399
\begin{itemize}
	\item Bezugsobjekt auf den Stack (falls nicht \texttt{static})
	\item Parameter auf den Stack
	\item \texttt{invokevirtual} oder \texttt{invokestatic} ausführen (weitere Details hierzu auf der Folie)
	\item \texttt{Return}-Wert vom Stack holen und weiterarbeiten
\end{itemize}

\subsubsection{Deskriptoren (S400)}
Namen von Klassen, Felder und Methoden müssen einem festgelegten Schema entsprechen. Beispiele sind auf der Folie zu finden.

\subsubsection{Objekt erzeugen und initialisieren (S401)}
\begin{itemize}
	\item Objekt anlegen und Speicher reservieren
	\item Danach Objekt initialisieren (Konstruktor aufrufen)
	\item Jede Klasse braucht mindestens den Default-Konstruktor
	\item Beispiel auf der Folie
\end{itemize}

\subsubsection{Weitere Beispiele}
\begin{itemize}
	\item Array anlegen und darauf zugreifen (S402)
	\item Auf Feld zugreifen (S403)
\end{itemize}

\subsection{Codeerzeugung}




\section{Appendix A: Haskell}

\subsection{Funktionen}

\begin{table}[h]
\begin{tabularx}{\textwidth}{l|X|X}
	\textbf{\textit{drop}} & \(Int \rightarrow [a] \rightarrow [a]\) & Gibt die Liste ohne die ersten \textit{n} zurück \\
	\textbf{\textit{head}} & \([a] \rightarrow a\) & Gibt das erste Element einer nicht-leeren Liste zurück \\
	\textbf{\textit{isDigit}} & & Erkennt eine Zahl \\
	\textbf{\textit{length}} & \([a] \rightarrow Int\) & Gibt die Länge einer Liste oder eines Texts zurück \\
	\textbf{\textit{map}} & \((a \rightarrow b) \rightarrow [a] \rightarrow [b]\) & \\
	\textbf{\textit{null}} & & Prüft, ob eine Liste leer ist \\
	\textbf{\textit{reverse}} & \([a] \rightarrow [a]\) & Gibt eine invertierte Form der Eingabeliste zurück \\
	\textbf{\textit{sort}} & \(Ord~a \Rightarrow [a] \rightarrow [a]\) & Gibt eine sortierte Form der Eingabeliste zurück \\
	\textbf{\textit{tail}} & \([a] \rightarrow [a]\) & Gibt eine Liste ohne Kopfelemente einer Eingabeliste zurück \\
	\textbf{\textit{take}} & \(Int \rightarrow [a] \rightarrow [a]\) & Gibt die ersten \textit{n} Elemente einer Liste zurück \\
	\textbf{\textit{zipWith}} & \((a \rightarrow b \rightarrow c) \rightarrow [a] \rightarrow [b] \rightarrow [c]\) & Kombiniert jeweils die Elemente zweier Listen über eine beliebige Funktion, beispielsweise \textit{(*)} \\
\end{tabularx}
\end{table}

\section{Appendix B: Typherleitungsregeln}

\subsection{\texttt{APP}}
\[APP:\frac{\Gamma \vdash t_1~:~\tau_2 \rightarrow \tau~~~~~~~\Gamma\vdash t_2~:~\tau_2}{\Gamma\vdash t_1t_2~:~\tau}\]

\section{Appendix C: Bytecode}

\subsection{Instruktionsklassen (S395)}
\begin{itemize}
	\item Lesen/Schreiben von lokalen Variablen: \texttt{?load, ?store <x>, ...}
	\item Lesen/Schreiben von Feldern: \texttt{getfield, putfield, ...}
	\item Sprungbefehle: \texttt{ifeq, ifnull, tableswitch, ...}
	\item Methodenaufrufe: \texttt{invokevirtual, invokestatic, ...}
	\item Objekterzeugung: \texttt{new, newarray, ...}
	\item Arithmetische Berechnung: \texttt{?mul, ?add, ...}
\end{itemize}