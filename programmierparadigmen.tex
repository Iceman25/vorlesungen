\chapter{Programmierparadigmen}

Zusammenfassung der Vorlesung "`Programmierparadigmen"' aus dem Wintersemester 2014.\footnote{\url{https://pp.info.uni-karlsruhe.de/lehre/WS201415/paradigmen/}}

\section{Funktionale Programmierung}

\subsection{Lazy Evaluation}

\subsubsection{Auswertung}
\begin{itemize}
	\item Struturierte Daten: Nur auswerten, falls wirklich benötigt wird
	\item Duplizierte Argumente: Auswertung maximal einmal (\textit{sharing})
	\item Pattern-Matching: So weit wie nötig, bis passendes Muster gematched
	\item Boolsche Operatoren: Auswertung bis zum ersten \textit{false} (\textit{short-circuit-Auswertung})
	\item \textbf{Nachteile}
	\begin{itemize}
		\item Erschwerte Fehlersuche
		\item Fehler, die beim Testen nicht beachten wurden, tauchen eventuell später im Betrieb auf
	\end{itemize}
\end{itemize}



\section{Theoretische Grundlagen}


\section{Logische Programmierung}

\subsection{Einführung in Prolog}
\begin{itemize}
	\item Situationsbeschreibung
	\item Definition von Objekten und Beziehungen zwischen Objekten
	\item Darstellbar als Terme eine freien Termalgebra
\end{itemize}

\subsubsection{Termsyntax}
\begin{itemize}
	\item Atome: z.B. \texttt{hans, inge, fritz, fisch}
	\item Zahlen: z.B. \texttt{3, 4.5}
	\item Variablen: z.B. \texttt{X, Y, \_X, X1, Fisch}
	\item Termlisten: z.B. \texttt{3, 4.5, X, fritz}
	\item Zusammengesetzt: z.B. \texttt{liebt(fritz,fisch), liebt(fritz,X)}
\end{itemize}

\subsubsection{Variablen}
Platzhalter für unbekannte Terme. Können auch "`Allgemeinheit"' ausdrücken, beispielsweise \texttt{liebt(X, fussball)} \(\rightarrow\) "`Alle lieben Fußball"'.

\subsubsection{Abfragen}
\begin{itemize}
	\item Alle Fakten werden zur Laufzeit in einer Datenbank gehalten
	\item Einleitung per \texttt{?}: z.B. \texttt{?liebt(fritz,fisch)}
	\item \textbf{Mehrfachlösungen}
	\begin{itemize}
		\item Durchsuche Datenbank von vorne nach hinten
		\item Versuche jeweils, Abfrageparameter mit Datenbankfaktor zu unifizieren
	\end{itemize}
	\item \textbf{Konjunktion von Abfragen}
	\begin{itemize}
		\item Konjunktion von Teilzielen getrennt durch Komma, entspricht logischem \(\wedge\)
		\item Erfülle Teilziele von links nach rechts und nehme jeweils erstes Ergebnis
		\item Mehrere Ergebnisse: Fahre mit dem ersten Ergebnis bis zum Ende fort, prüfe danach weitere Ergebnisse
		\item Nach Erfüllung eines Teilziels: Nächstes Teilziel erbt Instanziierung
	\end{itemize}
\end{itemize}

\subsubsection{Regeln}
\begin{itemize}
	\item Aufbau: Regelkopf (1 Term) und Regelrumpf (1+ Terme): \texttt{term :- termlist .}
	\item \texttt{:-} liest sich als \textit{wenn}, Kammata als \textit{und}
	\item \textbf{Beispiele}
	\begin{itemize}
		\item "`Wenn Inge X liebt und wenn X Fisch liebt, dann liebt Hugo X"':\newline\texttt{liebt(hugo,X) :- liebt(inge,X),liebt(X,fisch)}
		\item "`Wenn es jemanden gibt, der Fisch mag, dann liebt Emil Erna"':\newline\texttt{liebt(emil,erna) :- liebt(X,fisch)}
	\end{itemize}
\end{itemize}

\subsubsection{Logische Programmierung ist anders}
\begin{itemize}
	\item Keine herkömmlichen Variablen
	\item Prädikate liefern außer ihrer Erfüllbarkeit keinen Ergebniswert
	\item Aber Unifikation und Backtracking eingebaut
	\item Sehr gut geeignet für Such- und Constraintprobleme, weniger für Berechnungen
\end{itemize}


\subsection{Backtracking}


\subsection{Arithmetik und Listen}


\subsection{Der Cut}


\subsection{Unifikation und Resolution}


\subsection{Spracherweiterungen}


\subsection{Constraint Logic Programming}



\section{Typinferenz}

\subsection{Typinferenz: $\lambda$-Kalkül}


\subsection{Typinferenz: \textit{let}-Polymorphismus}



\section{Grundlagen der Prallelprogrammierung}
Motivation: Leistungssteigerung über steigende Taktfrequenzen hinaus.

\subsubsection{Programmieransätze gemäß der Computerarchitektur}
\begin{itemize}
	\item Gemeinsamer Speicher: Jeder Prozessor kann jede Speicherzelle ansprechen (z.B. Multikernrechner)
	\item Verteilter Speicher: Jeder Prozessor hat seinen eigenen Speicher, Kommunikation über \textit{Message Passing} (z.B. bei Computerclustern)
\end{itemize}
Bei sequentieller Programmierung arbeitet der Prozessor nacheinander einzelne Befehle aus dem Arbeitsspeicher ab (von-Neumann-Architektur).

Bei paralleler Programmierung wird in der Theorie häufig das \textit{PRAM-Modell} mit einer beliebigen Anzahl an Prozessoren mit
\begin{itemize}
	\item jeweils lokalem Speicher
	\item und synchronem Zugriff auf globalen, gemeinsam genutzten Speicher (in der Praxis eher problematisch bei der Umsetzung.
\end{itemize}

\subsubsection{Flynn's Taxonomy}
\begin{enumerate}
	\item \textit{Single Instruction x Single Data:} Klassische von-Neumann-Architektur, ein Befehlsstrom arbeitet auf dem Speicher
	\item \textit{Single Instruction x Multiple Data:} Ein Befehl wird auf gleichartige Daten (z.B. Arrays) angewendet, typischerweise in Vektorprozessoren früherer Supercomputers
	\item \textit{Multiple Instruction x Multiple Data:} Verschiedene Prozessoren arbeiten auf verschiedenen Daten, beispielsweise in heutigen Multicore-Maschinen
	\item \textit{Multiple Instruction x Single Data:} Mehrere Befehle werden gleichzeitig auf den gleichen Daten ausgeführt, beispielsweise in redundanten Architekturen oder in den Pipelines moderner Prozessoren (Ansicht ist umstritten)
\end{enumerate}

\subsubsection{Herausforderungen}
\begin{itemize}
	\item Bereits schrittweise Parallelität benötigt Synchronisation
	\item Kommunikation der Prozesse untereinander
	\item Wettlaufbedingungen und Verklemmungen
\end{itemize}
Idealerweise lassen sich Probleme für Parallelverarbeitung so zerlegen, dass sie ohne Abhängigkeiten berechnet werden können; auch stückweise Parallelisierung ist möglich.

\subsubsection{Mögliche Beschleunigung}
\begin{itemize}
	\item Speedup: \(S(p) = \frac{T(n,1)}{T(n,p)} = \frac{Anzahl~mit~einem~Prozessor}{Aufwand~mit~p~Prozessoren}\)
	\item Amdahls Gesetz berechnet die maximale Beschleunigung, die durch Parallelverarbeitung erreicht werden kann: \(\frac{1}{(1-P)+\frac{P}{N}}\)
\end{itemize}


\subsection{Fortgeschrittene Konzepte in Java}

\subsubsection{Multithreading in Java}
\begin{itemize}
	\item Threads vor Java oft eher schwierig zu implementieren (in C/C++ zusätzliche Bibliotheken notwendig)
	\item In Java bereits in der Sprache enthalten
	\item Nicht vorgegeben ist allerdings die interne Implementierung des Multithreading in der jeweiligen VM
	\item Erben von der Klasse \textit{Thread} oder implementieren des Interface \textit{Runnable}
	\item \(stop()\) mit Hilfe von Pollen realisiert; ein Thread, der nicht beendet werden will, kann von außen nicht "`sauber"' beendet werden
	\item Rückgabewerte über \(Thread.join()\) realisierbar oder durch die Verwendung von \(Callables\) oder \(Futures\)
\end{itemize}


\subsection{\textit{C/C++} Wiederholung}


\subsection{Message Passing Interface (MPI)}


\subsection{Scala}


\subsection{X10}



\section{Compiler}

\subsection{Einführung}


\subsection{Lexikalische Analyse}


\subsection{Syntaktische Analyse}


\subsection{Semantische Analyse}


\subsection{Java-Bytecode}


\subsection{Codeerzeugung}



\section{Appendix A: Haskell}

\subsection{Funktionen}

\begin{table}[h]
\begin{tabularx}{\textwidth}{l|X|X}
	\textbf{\textit{drop}} & \(Int \rightarrow [a] \rightarrow [a]\) & Gibt die Liste ohne die ersten \textit{n} zurück \\
	\textbf{\textit{head}} & \([a] \rightarrow a\) & Gibt das erste Element einer nicht-leeren Liste zurück \\
	\textbf{\textit{length}} & \([a] \rightarrow Int\) & Gibt die Länge einer Liste oder eines Texts zurück \\
	\textbf{\textit{map}} & \((a rightarrow b) rightarrow [a] rightarrow [b]\) & \\
	\textbf{\textit{reverse}} & \([a] \rightarrow [a]\) & Gibt eine invertierte Form der Eingabeliste zurück \\
	\textbf{\textit{sort}} & \(Ord~a \Rightarrow [a] \rightarrow [a]\) & Gibt eine sortierte Form der Eingabeliste zurück \\
	\textbf{\textit{tail}} & \([a] \rightarrow [a]\) & Gibt eine Liste ohne Kopfelemente einer Eingabeliste zurück \\
	\textbf{\textit{take}} & \(Int \rightarrow [a] \rightarrow [a]\) & Gibt die ersten \textit{n} Elemente einer Liste zurück \\
	\textbf{\textit{zipWith}} & \((a \rightarrow b \rightarrow c) \rightarrow [a] \rightarrow [b] \rightarrow [c]\) & Kombiniert jeweils die Elemente zweier Listen über eine beliebige Funktion, beispielsweise \textit{(*)} \\
\end{tabularx}
\end{table}