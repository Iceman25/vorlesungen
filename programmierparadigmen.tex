\chapter{Programmierparadigmen}

Zusammenfassung der Vorlesung "`Programmierparadigmen"' aus dem Wintersemester 2014.\footnote{\url{https://pp.info.uni-karlsruhe.de/lehre/WS201415/paradigmen/}}

\section{Funktionale Programmierung}

\subsection{Rekursion}
\begin{itemize}
	\item Auswertung: Zwischenausdrücke können mit Eingabegröße wachsen
	\item Speicherverbrauch in \(\mathcal{O}(n)\) bei \(\mathcal{O}(n)\) Aufrufen
	\item \textbf{Akkumulation}
	\begin{itemize}
		\item Übergebe Zwischenergebnisse in Hilfsparameter \texttt{acc}
		\item Speicherverbrauch in \(\mathcal{O}(1)\) bei \(\mathcal{O}(n)\) Aufrufen
	\end{itemize}
\end{itemize}

\subsubsection{Endrekursion}
\begin{itemize}
	\item Linearität: Eine Funktion heißt \textit{linear rekursiv}, wenn in jedem Defitionszweig nur ein rekursiver Aufruf vorkommt.
	\item Endrekursion: Eine linear rekursive Funktion heißt \textit{endrekursiv}, wenn in jedem Zweig der rekursive Aufruf nicht in andere Aufrufe eingebettet ist.
\end{itemize}


\subsection{Listen}
\begin{itemize}
	\item Eine Liste \texttt{(x:xs)} besteht immer aus Listenkopf \texttt{x} und Listenrest \texttt{xs}
\end{itemize}

\subsubsection{Pattern Matching}
\begin{itemize}
	\item Mehrere Gleichungen zur Definition einer Funktion
	\item Jede Gleichung gilt für Argumente mit speziellem Strukturmuster
	\item Überlappende Muster: Erste Gleichung wird angewandt
\end{itemize}


\subsection{Funktionen höherer Ordnung}

\subsubsection{Lambda-Notation}
\begin{itemize}
	\item Anonyme Funktionen und Funktionen höherer Ordnung möglich
	\item Beispiel: \(g(x,y)=x-\frac{y}{2} \longrightarrow\) \texttt{g = \textbackslash x y -> x - 2/y}
\end{itemize}

\subsubsection{Definition: Funktion höherer Ordnung}
Funktionen, die andere Funktionen als Parameter erhalten oder Funktionen als Rückgabewerte liefern, heißen Funktionen höherer Ordnung.

\subsubsection{Currying}
\begin{itemize}
	\item Ersetzung einer mehrstelligen Funktion durch Schachtelung einstelliger Funktionen.
	\item Jede Funktion erhält, wie oben erwähnt, nur ein Argument. Werden scheinbar mehrere Argumente definiert, so steckt immer Currying dahinter.
	\item Unterversorgung: Anwendung mehrstelliger Funktionen auf zu wenig Parameter
\end{itemize}

\textbf{Beispiel\footnote{\url{https://de.wikipedia.org/wiki/Currying\#Haskell}}}

\begin{lstlisting}[frame=single,numbers=left,mathescape,language=Haskell]
addiere x y = x + y
addiere 1 3                -- ist aequivalent zu (addiere 1) 3
addiereZu2  = addiere 2
addiereZu2 1               -- 3
\end{lstlisting}

\subsubsection{Namensbindung}
\begin{itemize}
	\item Bindungsstrukte legen Bedeutung und Geltungsbereiche von Variablen fest
	\item Verdeckung: Innere Bindungen verdecken äußere
	\item \textbf{Bindung}
	\begin{itemize}
		\item \texttt{f x = x*x}: Bindung von \texttt{x} im Rumpf von \texttt{f}, globale Bindung von \texttt{f}
		\item \texttt{\textbackslash x -> x*x}: Bindung von \texttt{x} innerhalb des \(\lambda\)-Ausdrucks
	\end{itemize}
\end{itemize}

\subsubsection{Lokale Bindung}
\begin{itemize}
	\item Anwendung: Lokale Hilfsfunktionen
	\item \texttt{let} bindet stärker als \texttt{where}
\end{itemize}

\textbf{Beispielse}

\begin{lstlisting}[frame=single,numbers=left,mathescape,language=Haskell]
energy m = let c = 299792458
           in m * c * c

energy m = m * c * c
  where c = 299792458
\end{lstlisting}

\subsection{Kombinatoren}

\subsubsection{Folds}
\begin{itemize}
	\item Anwendung einer Operation und eines Initialwertes auf eine Liste
	\item \textbf{Beispiel Summenberechnung}
	\begin{itemize}
		\item \texttt{sum = (+) 0}
		\item Berechnung mittels \texttt{foldr}: \texttt{(1 + (2 + (3 + (4 + 0))))} (rechts-geklammert)
		\item Berechnung mittels \texttt{foldl}: \texttt{((((1 + 0) + 2) + 3) + 4)} (links-geklammert)
	\end{itemize}
	\item Anwendung: Koplexe Funktionen als Kombination einfacher Funktionen
\end{itemize}

\subsubsection{Kombination von Listen}
\begin{itemize}
	\item Zusammenfügen von Listen per Reißverschluss: \texttt{zip = zipWith (,)}
	\item \texttt{zipWith} definiert eine Zusätzliche Operation
	\item Bricht ab, wenn eine der Listen keine weiteren Elemente enthält
\end{itemize}

\subsubsection{List Comprehensions}
\begin{itemize}
	\item Automatisiertes Erzeugen von Listen, basierend auf bereits existierenden Listen
	\item Inspiriert durch die mathematische Mengenschreibweise: \texttt{s = {[} 2 * x {|} x <- {[}0..{]}, x\textasciicircum 2 > 3 {]} } \footnote{\url{https://en.wikipedia.org/wiki/List_comprehension\#Haskell}}
	\item Multidimensionale Liste: \texttt{s = {[} 2*x*y {|} x <- {[}0..{]}, x\textasciicircum2 > 3, y <- {[}1,3..x{]}, y\textasciicircum2 < 100-x\textasciicircum2 {]}}
\end{itemize}


\subsection{Lazy Evaluation}

\subsubsection{Auswertung}
\begin{itemize}
	\item Struturierte Daten: Nur auswerten, falls wirklich benötigt wird
	\item Duplizierte Argumente: Auswertung maximal einmal (\textit{sharing})
	\item Pattern-Matching: So weit wie nötig, bis passendes Muster gematched
	\item Boolsche Operatoren: Auswertung bis zum ersten \textit{false} (\textit{short-circuit-Auswertung})
	\item \textbf{Nachteile}
	\begin{itemize}
		\item Erschwerte Fehlersuche
		\item Fehler, die beim Testen nicht beachten wurden, tauchen eventuell später im Betrieb auf
	\end{itemize}
\end{itemize}


\subsection{Typen}
\begin{itemize}
	\item Haskell ist statisch typisiert
	\item Jeder gültige Ausdruck hat immer einen Typ und wertet immer zu gültigen Werten dieses Typs aus
	\item Schreibweise: \texttt{e :: t} falls Ausdruck \texttt{e} und Typ \texttt{t}
	\item Untypisierbare Ausdrücke erzeugen Übersetzerfehler
	\item Haskell erkennt den korrekten Typ (fast immer) zuverlässig, optional manuelle Deklaration möglich
	\item Typinferenz: Errechnen der Typen durch den Compiler. Kompakte Programme und trotzdem typsicher
	\item Typsynonyme: Ableiten neuer Typen aus vorhandenen. Z.B. \texttt{type String = {[}char{]}} (kann die Lesbarkeit erhöhen). Es werden keine explizit neuen Typen erzeugt
\end{itemize}


\subsection{Algebraische und rekursive Datentypen}

\subsubsection{Nachteile von Tupeln}
\begin{itemize}
	\item Produkttypen: Typen mit mehreren Komponenten. Beispiel: Personen mit Name und Alter \texttt{type Person = (String, Int)}
	\item Nachteil: Bedeutung von Werten nicht explizit; ungewollte Verwendung beliebiger \texttt{(String, Int)} Tupel
\end{itemize}

\subsubsection{Algebraische Datentypen}
\begin{itemize}
	\item Verwendung des Schlüsselwortes \texttt{data} statt \texttt{type} zur definition \textit{neuer} Typen
	\item Mehrere Konstruktoren möglich
\end{itemize}

\subsection{Anwendung algebraischer Datentypen}
\begin{itemize}
	\item \textbf{Algebraischer Datenstrukturen ermöglichen}
	\begin{itemize}
		\item Implementierung von Datenstrukturen
		\item Modellierung problemspezifischer Daten
	\end{itemize}
	\item \textbf{Einsatz von Pattern-Matching}
	\begin{itemize}
		\item Erleichtert Umsetzung komplexer Algorithmen
		\item Besonders für baumartige Strukturen
	\end{itemize}
	\item \textbf{Anwendungsbeispiele}
	\begin{itemize}
		\item Datenstrukturen: Maps, Bäume, Rot-Schwarz-Bäume
		\item Fehlerbehandlung
		\item Termersetzungssysteme
	\end{itemize}
\end{itemize}



\section{Theoretische Grundlagen}
Kalküle sind minimalistische Programmiersprachen zur Beschreibung von Berechnungen.	

\subsection{Der untypisierte $\lambda$-Kalkül}
\begin{itemize}
	\item Turing-mächtiges Modell funktionaler Programme zur Beschreibung sqeuentieller imperativer Konstrukte
	\item Linkassoziative Funktionsanwendung
	\item \(\lambda\)-Term: Ein Term der Form \texttt{(\(\lambda\)x.\(t_1\))\(t_2\)}
	\item \textbf{\(\alpha\)-Äquivalenz}
	\begin{itemize}
		\item \(t_1\) und \(t_2\) heißen \(\alpha\)-äquivalent, wenn \(t_1\) in \(t_2\) durch konsistente Umbenennung der \(\lambda\)-gebundenen Variablen überführt werden kann
		\item Funktionsbezeichnungen dürfen nicht geändert werden
		\item Beispiel: \texttt{\(\lambda\)x. (\(\lambda\)z. f(\(\lambda\)y. z y) x) = \(\lambda\)y. (\(\lambda\)x. f(\(\lambda\)z. x z) y)}
	\end{itemize}
	\item \textbf{\(\eta\)-Äquivalenz}
	\begin{itemize}
		\item Zwei Funktionen genau dann gleich sind, wenn sie für alle Argumente dasselbe Resultat liefern\footnote{\url{https://de.wikipedia.org/wiki/Lambda-Kalkül\#.CE.B7-Konversion}}
		\item Terme \texttt{\(\lambda\)x. f x} und \texttt{f} heißen \(\eta\)-äquivalent, falls \texttt{x} eine nicht-freie Variable von \texttt{f} ist
	\end{itemize}
\end{itemize}

\subsubsection{$\beta$-Reduktion}
\begin{itemize}
	\item Formalisiert das Konzept der Funktionsanwendung
	\item Anwendung ausschlißelich von links nach rechts
	\item Eine \(\beta\)-Reduktion entspricht der Ausführung der Funktionsanwendung auf einem Redex: \texttt{(\(\lambda\)x.\(t_1\))\(t_2 \Rightarrow\) \(t_1\){[} x \(\mapsto t_2\) {]}}
	\item Volle \(\beta\)-Reduktion: Jeder Redex kann reduziert werden
	\item \textbf{Beispiele}
	\begin{itemize}
		\item \texttt{(\(\lambda\)x.x)y \(\Rightarrow\) x{[} x \(\mapsto\) y {]} = y}
		\item \texttt{(\(\lambda\)x.x (\(\lambda\)x.x))(y z) \(\Rightarrow\) (x (\(\lambda\)x.x)){[} x \(\mapsto\) y z {]} = (y z)(\(\lambda\)x.x)}
	\end{itemize}
	\item \textbf{Kodierung mit Funktionen höherer Ordnung}
	\begin{itemize}
		\item Man braucht nicht unbedingt primitive Operationen
		\item Beispiel: \texttt{let}
		\item \texttt{let x = \(t_1\) in \(t_2\)} wird zu \texttt{(\(\lambda\)x.\(t_2\)) \(t_1\))}
		\item \texttt{let x = g y in f x = (\(\lambda\)x.f x)(g y) \(\Rightarrow\) f(g y)}
	\end{itemize}
\end{itemize}

\subsubsection{Kodierung natürlich Zahlen}
\begin{itemize}
	\item Einbettung von Daten und Operationen in den \(\lambda\)-Kalkül
	\item Eine (natürliche) Zahl drückt aus, wie oft die Funktion \texttt{s} angewendet wird
	\item \textbf{Church-Zahlen}
	\begin{itemize}
		\item \texttt{\(c_0\) = \(\lambda\)s.\(\lambda\)z.z}
		\item \texttt{\(c_1\) = \(\lambda\)s.\(\lambda\)z.s z}
		\item \texttt{\(c_2\) = \(\lambda\)s.\(\lambda\)z.s (s z)}
		\item \texttt{\(c_3\) = \(\lambda\)s.\(\lambda\)z.s (s (s z))} \\ \(\vdots\)
		\item \texttt{\(c_n\) = \(\lambda\)s.\(\lambda\)z.\(s^n\) z}
	\end{itemize}
	\item Nachfolgerfunktion \texttt{succ} errechnet den Nachfolger. Beispielsweise ist \texttt{succ(\(c_2\)) = \(c_3\)}
\end{itemize}


\section{Logische Programmierung}

\subsection{Einführung in Prolog}
\begin{itemize}
	\item Situationsbeschreibung
	\item Definition von Objekten und Beziehungen zwischen Objekten
	\item Darstellbar als Terme einer freien Termalgebra
\end{itemize}

\subsubsection{Termsyntax}
\begin{itemize}
	\item Atome: z.B. \texttt{hans, inge, fritz, fisch}
	\item Zahlen: z.B. \texttt{3, 4.5}
	\item Variablen: z.B. \texttt{X, Y, \_X, X1, Fisch}
	\item Termlisten: z.B. \texttt{3, 4.5, X, fritz}
	\item Zusammengesetzt: z.B. \texttt{liebt(fritz,fisch), liebt(fritz,X)}
\end{itemize}

\subsubsection{Variablen}
Platzhalter für unbekannte Terme. Können auch "`Allgemeinheit"' ausdrücken, beispielsweise \texttt{liebt(X, fussball)} \(\rightarrow\) "`Alle lieben Fußball"'.

\subsubsection{Abfragen}
\begin{itemize}
	\item Alle Fakten werden zur Laufzeit in einer Datenbank gehalten
	\item Einleitung per \texttt{?}: z.B. \texttt{?liebt(fritz,fisch)}
	\item \textbf{Mehrfachlösungen}
	\begin{itemize}
		\item Durchsuche Datenbank von vorne nach hinten
		\item Versuche jeweils, Abfrageparameter mit Datenbankfaktor zu unifizieren
	\end{itemize}
	\item \textbf{Konjunktion von Abfragen}
	\begin{itemize}
		\item Konjunktion von Teilzielen getrennt durch Komma, entspricht logischem \(\wedge\)
		\item Erfülle Teilziele von links nach rechts und nehme jeweils erstes Ergebnis
		\item Mehrere Ergebnisse: Fahre mit dem ersten Ergebnis bis zum Ende fort, prüfe danach weitere Ergebnisse
		\item Nach Erfüllung eines Teilziels: Nächstes Teilziel erbt Instanziierung
	\end{itemize}
\end{itemize}

\subsubsection{Regeln}
\begin{itemize}
	\item Aufbau: Regelkopf (1 Term) und Regelrumpf (1+ Terme): \texttt{term :- termlist .}
	\item \texttt{:-} liest sich als \textit{wenn}, Kommata als \textit{und}
	\item \textbf{Beispiele}
	\begin{itemize}
		\item "`Wenn Inge X liebt und wenn X Fisch liebt, dann liebt Hugo X"':\newline\texttt{liebt(hugo,X) :- liebt(inge,X),liebt(X,fisch)}
		\item "`Wenn es jemanden gibt, der Fisch mag, dann liebt Emil Erna"':\newline\texttt{liebt(emil,erna) :- liebt(X,fisch)}
	\end{itemize}
\end{itemize}

\subsubsection{Logische Programmierung ist anders}
\begin{itemize}
	\item Keine herkömmlichen Variablen
	\item Prädikate liefern außer ihrer Erfüllbarkeit keinen Ergebniswert
	\item Aber Unifikation und Backtracking eingebaut
	\item Sehr gut geeignet für Such- und Constraintprobleme, weniger für Berechnungen
\end{itemize}


\subsection{Backtracking}


\subsection{Arithmetik und Listen}


\subsection{Der Cut}


\subsection{Unifikation und Resolution}


\subsection{Spracherweiterungen}


\subsection{Constraint Logic Programming}



\section{Typinferenz}

\subsection{Typinferenz: $\lambda$-Kalkül}


\subsection{Typinferenz: \textit{let}-Polymorphismus}



\section{Grundlagen der Prallelprogrammierung}
Motivation: Leistungssteigerung über steigende Taktfrequenzen hinaus.

\subsubsection{Programmieransätze gemäß der Computerarchitektur}
\begin{itemize}
	\item Gemeinsamer Speicher: Jeder Prozessor kann jede Speicherzelle ansprechen (z.B. Multikernrechner)
	\item Verteilter Speicher: Jeder Prozessor hat seinen eigenen Speicher, Kommunikation über \textit{Message Passing} (z.B. bei Computerclustern)
\end{itemize}
Bei sequentieller Programmierung arbeitet der Prozessor nacheinander einzelne Befehle aus dem Arbeitsspeicher ab (von-Neumann-Architektur).

Bei paralleler Programmierung wird in der Theorie häufig das \textit{PRAM-Modell} mit einer beliebigen Anzahl an Prozessoren mit
\begin{itemize}
	\item jeweils lokalem Speicher
	\item und synchronem Zugriff auf globalen, gemeinsam genutzten Speicher (in der Praxis eher problematisch bei der Umsetzung.
\end{itemize}

\subsubsection{Flynn's Taxonomy}
\begin{enumerate}
	\item \textit{Single Instruction x Single Data:} Klassische von-Neumann-Architektur, ein Befehlsstrom arbeitet auf dem Speicher
	\item \textit{Single Instruction x Multiple Data:} Ein Befehl wird auf gleichartige Daten (z.B. Arrays) angewendet, typischerweise in Vektorprozessoren früherer Supercomputers
	\item \textit{Multiple Instruction x Multiple Data:} Verschiedene Prozessoren arbeiten auf verschiedenen Daten, beispielsweise in heutigen Multicore-Maschinen
	\item \textit{Multiple Instruction x Single Data:} Mehrere Befehle werden gleichzeitig auf den gleichen Daten ausgeführt, beispielsweise in redundanten Architekturen oder in den Pipelines moderner Prozessoren (Ansicht ist umstritten)
\end{enumerate}

\subsubsection{Herausforderungen}
\begin{itemize}
	\item Bereits schrittweise Parallelität benötigt Synchronisation
	\item Kommunikation der Prozesse untereinander
	\item Wettlaufbedingungen und Verklemmungen
\end{itemize}
Idealerweise lassen sich Probleme für Parallelverarbeitung so zerlegen, dass sie ohne Abhängigkeiten berechnet werden können; auch stückweise Parallelisierung ist möglich.

\subsubsection{Mögliche Beschleunigung}
\begin{itemize}
	\item Speedup: \(S(p) = \frac{T(n,1)}{T(n,p)} = \frac{Anzahl~mit~einem~Prozessor}{Aufwand~mit~p~Prozessoren}\)
	\item Amdahls Gesetz berechnet die maximale Beschleunigung, die durch Parallelverarbeitung erreicht werden kann: \(\frac{1}{(1-P)+\frac{P}{N}}\)
\end{itemize}


\subsection{Fortgeschrittene Konzepte in Java}

\subsubsection{Multithreading in Java}
\begin{itemize}
	\item Threads vor Java oft eher schwierig zu implementieren (in C/C++ zusätzliche Bibliotheken notwendig)
	\item In Java bereits in der Sprache enthalten
	\item Nicht vorgegeben ist allerdings die interne Implementierung des Multithreading in der jeweiligen VM
	\item Erben von der Klasse \textit{Thread} oder implementieren des Interface \textit{Runnable}
	\item \(stop()\) mit Hilfe von Pollen realisiert; ein Thread, der nicht beendet werden will, kann von außen nicht "`sauber"' beendet werden
	\item Rückgabewerte über \(Thread.join()\) realisierbar oder durch die Verwendung von \(Callables\) oder \(Futures\)
\end{itemize}


\subsection{\textit{C/C++} Wiederholung}


\subsection{Message Passing Interface (MPI)}


\subsection{Scala}


\subsection{X10}



\section{Compiler}

\subsection{Einführung}
\begin{itemize}
	\item Reiner Übersetzer: Liest den Quelltext Anweisung für Anweisung; billig; sinnvoll bei Kommandasprachen (Unix-Shell)
	\item Interpretation nach Vorübersetzer: Transformation in eine günstigere Form; nicht unbedingt maschinennah; beispielsweise Java-Bytecode oder Python
	\item Vollständige Übersetzung: Übersetzung in Maschinencode,; Zielsprache beschreibt eine abstrakte Laufzeitmaschine, definiert durch Hardware, Betriebssystem, etc; beispielsweise C/C++ oder Fortran
	\item Just-in-time-Compiler: Übersetzung bedarfsgerecht während der Ausführung; beispielsweise die moderne JVM oder .NET
\end{itemize}


\subsection{Lexikalische Analyse}


\subsection{Syntaktische Analyse}


\subsection{Semantische Analyse}


\subsection{Java-Bytecode}


\subsection{Codeerzeugung}



\section{Appendix A: Haskell}

\subsection{Funktionen}

\begin{table}[h]
\begin{tabularx}{\textwidth}{l|X|X}
	\textbf{\textit{drop}} & \(Int \rightarrow [a] \rightarrow [a]\) & Gibt die Liste ohne die ersten \textit{n} zurück \\
	\textbf{\textit{head}} & \([a] \rightarrow a\) & Gibt das erste Element einer nicht-leeren Liste zurück \\
	\textbf{\textit{isDigit}} & & Erkennt eine Zahl \\
	\textbf{\textit{length}} & \([a] \rightarrow Int\) & Gibt die Länge einer Liste oder eines Texts zurück \\
	\textbf{\textit{map}} & \((a \rightarrow b) \rightarrow [a] \rightarrow [b]\) & \\
	\textbf{\textit{null}} & & Prüft, ob eine Liste leer ist \\
	\textbf{\textit{reverse}} & \([a] \rightarrow [a]\) & Gibt eine invertierte Form der Eingabeliste zurück \\
	\textbf{\textit{sort}} & \(Ord~a \Rightarrow [a] \rightarrow [a]\) & Gibt eine sortierte Form der Eingabeliste zurück \\
	\textbf{\textit{tail}} & \([a] \rightarrow [a]\) & Gibt eine Liste ohne Kopfelemente einer Eingabeliste zurück \\
	\textbf{\textit{take}} & \(Int \rightarrow [a] \rightarrow [a]\) & Gibt die ersten \textit{n} Elemente einer Liste zurück \\
	\textbf{\textit{zipWith}} & \((a \rightarrow b \rightarrow c) \rightarrow [a] \rightarrow [b] \rightarrow [c]\) & Kombiniert jeweils die Elemente zweier Listen über eine beliebige Funktion, beispielsweise \textit{(*)} \\
\end{tabularx}
\end{table}