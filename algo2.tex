\chapter{Algorithmen II}

Zusammenfassung der Vorlesung "`Algorithmen II"' aus dem Wintersemester 2014.\footnote{\url{http://geom.ivd.kit.edu/ws14_algo2.php}}


\section{Flussmaximierung}

\subsection{Flussnetzwerke}
\textbf{Ziel:} Berechnung des maximalen Flusses.

\subsubsection{Bestandteile}
\begin{itemize}
	\item Graph mit Quelle q und Senke s: \(G(V,E)\) mit \(E \subset V^2\)
	\item Kapazitätsfunktion \(k : V^2 \rightarrow \mathbb{R}_{+0}\), wobei \(\forall e \in V^2 \setminus E: k(e) = 0\)
\end{itemize}

\subsubsection{Flüsse}
Ein Fluss in F ist eine Funktion \(f:V^2\rightarrow\mathbb{R}\) mit den Eigenschaften:
\begin{enumerate}
	\item \(f \leq k\)
	\item \(\forall x,y \in V : f(x,y) = -f(y,x)\)
	\item \(\forall x \in V \setminus \{ q,s \}: 0 = \sum f(x,V) := \sum_{y\in V} f(x,y)\)
\end{enumerate}

\subsubsection{Bemerkungen}
\begin{itemize}
	\item Der negative Fluss soll lediglich die Darstellung vereinfachen und ist ansonsten uninteressant
	\item In alle Knoten außer in \(q\) und in \(s\) fließt immer so viel positiver Fluss rein wie raus
	\item Flussnetzwerke können zu einem Flussnetzwerk zusammengafasst werden (mit unendlichen Zu- und Abflüssen)
\end{itemize}


\subsection{Algorithmus von Ford und Fulkerson}
\begin{itemize}
	\item \textbf{Algorithmus}
	\begin{enumerate}
		\item Setze die Flüsse an alle Kanten gleich Null
		\item Solange es einen Pfad von \(q\) nach \(s\) gibt, erhöhe einen beliebigen Pfad
	\end{enumerate}
	\item Terminiert Ford-Fulkerson, ist \(f\) maximal
	\item Aufwand: \(\mathcal{O}(|E| \cdot max\{W_f | f~Fluss~in~F\})\)
\end{itemize}


\subsection{Algorithmus von Edmonds und Karp}
\begin{itemize}
	\item Idee: Anwendung von Ford-Fulkerson immer längs eines kürzesten Pfades (Breitensuche)
	\item Aufwand: \(\mathcal{O} (|E|^2 \cdot |V|)\)
\end{itemize}


\subsection{Präfluss-Pusch-Methode}
Jeder Knoten erhält zusätzlich eine Höhe und ein Reservoir, um vorübergehend beliebig viel Fluß speichern zu können.

\subsubsection{Operationen}

\paragraph{\(PUSCH(x,y)\)}
\begin{itemize}
	\item \textbf{Bedingungen}
	\begin{itemize}
		\item Überschuss bei \(x\) vorhanden: \(u(x) > 0, x \in V \setminus \{q,s\}\)
		\item \(x\) liegt höher als \(y\): \(h(x) - h(y) = 1\)
	\end{itemize}
	\item \textbf{Algorithmus}
	\begin{enumerate}
		\item Ermittle den Abfluss aus Überschuss und Restkapazität: \(min\{u(x), k_f(x,y)\}\)
		\item Erhöhe den Fluss auf der Kante \(x,y)\)
		\item Aktualisiere die Überschusswerte an \(x\) und \(y\)
	\end{enumerate}
\end{itemize}

\paragraph{\(LIFTE(x)\)}
\begin{itemize}
	\item \textbf{Bedingungen}
	\begin{itemize}
		\item Der Knoten ist weder \(q\) und \(s\)
		\item Überschuss bei \(x\) vorhanden
		\item \(x\) kann nur geliftet werden, wenn kein Pfad \(y \rightarrow x\) eine höhere Restkapazität aufweist: \(h(x) < h(y)\)
	\end{itemize}
	\item \textbf{Algorithmus}
	\begin{enumerate}
		\item Erhöhe \(x\): \(h(x) = 1 + min\{h(y)\}\)
	\end{enumerate}
\end{itemize}

\paragraph{PRAEFLUSS-PUSCH}
\begin{enumerate}
	\item \textbf{Initialisiere}
	\begin{enumerate}
		\item Alle Knoten außer \(q\) bekommen die Höhe \(0\) (\(h(q) = |V|)\)
		\item Alle Pfade von \(q\) bekommen die Kapazität nach \(k(x,y)\) zugewiesen, alle anderen Pfade \(0\)
	\end{enumerate}
	\item Solange es eine beliebige, erlaubte Operation gibt, führe diese aus
\end{enumerate}

\subsubsection{Laufzeit}
\[\mathcal{O} (|V|^2 \cdot |E|)\]


\subsection{Move-to-Front-Algorithmus}
Durch eine strukturierte Abarbeitung der Operationen wird \textit{Präfluss-Pusch} beschleunigt.

\begin{itemize}
	\item Idee: Strukturierstes enladen der Knoten
	\item Die Knoten werden über eine Liste verwaltet
	\item Geliftete Knoten werden an die Spitze der Liste gesetzt
\end{itemize}

\subsubsection{Operationen}

\paragraph{\(LEERE(x)\)}
\begin{enumerate}
	\item Solange \(u(x)\ > 0\)
	\item Falls es einen puschbaren Nachbarknoten gibt: \(PUSCH(x,y)\)
	\item Falls nicht, \(LIFTE(x)\)
\end{enumerate}

\paragraph{\(AN~DIE~SPITZE\)}
\begin{enumerate}
	\item Initialisiere wie in \textit{PRAEFLUSS-PUSCH}
	\item Generierte die Knotenliste \(L\)
	\item Iteriere über alles Knoten
	\item Bestimme für jeden Knoten die Anzahl der Nachbarknoten
	\item Iteriere über \(L\)
	\begin{enumerate}
		\item \(LEERE(x)\)
		\item Wenn erfolgreich geleert wurde, setze den aktuellen Knoten an die Spitze von \(L\)
	\end{enumerate}
\end{enumerate}

\subsubsection{Laufzeit}
\[\mathcal{O}(|V|^3)\]



\section{Zuordnungsprobleme}
\textbf{Ziel:} Verteilung verschiedener Aufgaben auf eine Gruppe von Personen mit unterschiedlichen Fähigkeiten.

\subsection{Paaren in bipartiten Graphen}
\begin{itemize}
	\item Eine Paarung beinhaltet zwei Knoten exklusiv
	\item Eine Paarung heißt maximal, wenn es keine bessere Paarung gibt
	\item Maximale Paarung über Flußmaximierung: Ergänzung des bipartiten Graphs um Quelle und Senke
\end{itemize}


\subsection{Paaren in allgemeinen Graphen}
Sei \(G=(V,E)\) ein Graph mit einer Paarung \(P\) und einer maximalen Paarung \(Q\).

\subsubsection{Symmetrische Differenz}
\[D:=(P\setminus Q) \cup (Q \setminus P)\]
Die Kanten dieser Wege liegen alternierend in \(P\) und \(Q\) \(\rightarrow\) Zyklen haben eine gerade Länge.

\subsubsection{Definition}
Es gibt \(k=|Q\setminus (P \cap Q)| - |P\setminus (P \cap Q)|\) Wege, auf denen \(P\) vergrößert werden kann.

\subsubsection{Folgerung}
Man kann eine maximale Paarung durch sukzessive Vergrößerungen finden.

\paragraph{Algorithmus zur Vergößerung}
Scheitert in allgemeinen Graphen, funktioniert lediglich in bipartiten Graphen.
\begin{enumerate}
	\item Suche \((x,y) \in E\), wobei \(x\) mit keinem \(z\in V\) gepaart
	\item Setze \((x,y)\) durch Breitensuche zu einem alternierden Weg \(W\) ungerade Länge fort
\end{enumerate}

\subsubsection{Blüten}
\begin{itemize}
	\item Zu Problemen kommt es bei sogenannten Blüten
	\item Lösung: Man schrumpft die Blüten ohne ihren Stil zu einem Knoten
\end{itemize}

\subsubsection{Aufwand der Suche nach vergrößernden Wegen}
\[\mathcal{O}(\sqrt{|V|} \cdot |E|)\]


\subsection{Maximal gewichtete Paarung}
Gesucht: Maximal gewichtete Paarung eines ungerichteten Graph:
\[\Gamma(P) := \Sigma \gamma (P)\]

\subsubsection{Annahme}
Man kann eine maximal gewichtete Paarung finden, indem eine maximal gewichtete Kante iterativ durch einen vergrößernden Weg zu einer nächstgrößeren Paarung vergrößert wird.

\paragraph{Aufwand}
\[\mathcal{O}(min\{|V|^3, |V| \cdot |E| \cdot log|V|\})\]



\section{Stochastische Algorithmen}

\subsection{Erwartungswert}
Der Erwartungswert einer Zufallsvariablen beschreibt die Zahl, die die Zufallsvariable im Mittel annimmt.\footnote{\url{http://de.wikipedia.org/wiki/Erwartungswert}}

\subsubsection{Sigma-Additivität}
\[\mathbb{E}\lbrack \Sigma X_i\rbrack = \Sigma E \lbrack X_i\rbrack\]


\subsection{Quicksort}
\begin{itemize}
	\item Sortieren durch stochastisches Teilen
	\item Aufwandsabschätzung anhand der durchgeführten Vergleiche
\end{itemize}


\subsection{Minimaler Schnitt}

\subsubsection{Definitionen}
\begin{itemize}
	\item Ereignisse: Die Teilmengen einer Stichprobenmenge
	\item Bedingte Wahrscheinlichkeit: \(Pr \lbrack E_1 | E_2 \rbrack := \frac{Pr\lbrack E_1 \cap E_2 \rbrack}{Pr\lbrack E_2 \rbrack} \)
	\item Multigraph: Kanten können mehrfach vorkommen
\end{itemize}

\subsubsection{Algorithmus zur Berechnung des Schnitts}
\begin{enumerate}
	\item Solange \(|V| \geq 3\)
	\begin{enumerate}
		\item Wähle zufällig eine Kante \((x,y)\)
		\item Entferne alle \((x,y)\) aus \(E\)
		\item Verschmelze \(x\) mit \(y\)
	\end{enumerate}
\end{enumerate}



\section{Technik der Spieltheorie}
Aufwandsabschätzung von Las-Vegas-Algorithmen nach unten.

\subsection{Nullsummenspiele}
\begin{itemize}
	\item Bedingung: \(Gewinn(A) + Gewinn(B) = 0\)
	\item Definiert durch eine \(n \times m\) Matrix \(M\)
\end{itemize}

\subsubsection{Strategien}
\begin{itemize}
	\item Die Zeilen von \(M\) heißen Strategien von \(A\), die Spalten von \(M\) heißen Strategien von \(B\)
	\item Zeile \(i\) ist eine optimale Strategie für \(A\) und maximiert den Mindestgewinn: \(min_j~M_{ij}\)
	\item Spalte \(j\) ist eine optimale Strategie für \(B\) und minimiert den Maximalverlust: \(max_j~M_{ij}\)
	\item Wählen beide optimale Strategien: \(max_i~min_j~M_{ij} \leq Gewinn(A) \leq min_j~max_i~M_{ij}\)
\end{itemize}


\subsection{MiniMax-Theorem}

\subsubsection{Definitionen}
\begin{enumerate}
	\item \(p := \lbrack p_1,...,p_m \rbrack \) bezeichnet die \textit{gemischte Strategie} von \(A\)
	\item \(q := \lbrack q_1,...,q_n \rbrack \) bezeichnet die \textit{gemischte Strategie} von \(B\)
	\item Erwartungswert des Gewinns von \(A\): \(\mathbb{E}\lbrack Gewinn(A) \rbrack = p^T \cdot M \cdot q\)
	\item Optimale Strategie von \(A\): \(min_q~(p^T \cdot M \cdot q)\)
	\item Optimale Stratie für beide: \\ \(max_p~min_q~(p^T \cdot M \cdot q) \leq E \lbrack Gewinn(A) \rbrack \leq min_q~max_p~(p^T \cdot M \cdot q)\)
\end{enumerate}

\subsubsection{Von-Neumanns-MiniMax-Theorem}
\[max_p~min_q~(p^T \cdot M \cdot q) = min_q~max_p~(p^T \cdot M \cdot q)\]

Für ein festes \(p\) wird \(p^T \cdot M \cdot q\) minimiert, wenn die j-te Koordinate von \(p^T \cdot M\) minimal ist (siehe Satz von Loomi).


\subsection{Yoas Technik}
Verwendung des MiniMax-Theorems zur Laufzeitabschätzung von stochastischen Algorithmen für ein Problem \(P\):
\(B\) wählt einen Algorithmus \(A \in \{A_1,...,A_m\}\) und \(A\) wählt eine Eingabe \(E \in \{E_1,...,E_n\}\)
\begin{itemize}
	\item Worst-case-Laufzeit von \(A\): \(max_i~M_{ij}\)
	\item Deterministische Laufzeit von \(A\): \(min_j~max_i~M_{ij}\)
	\item Best-case-Laufzeit von \(A\): \(min_j~M_{ij}\)
	\item Stochastische Komplexität (Laufzeit) von \(A\) bzgl. \(P\): \(max_i~min_j~M_{ij} =: K_s\)
	\item Erwartungswert der Laufzeit: \(\mathbb{E}\lbrack Laufzeit \rbrack: \sum_{ij} p_i \cdot M_{ij} \cdot q =: p^T \cdot M \cdot q\)
	\item Verteilungskomplexität: \(K_v := max_p~min_q~(p^T \cdot M \cdot q)\)
\end{itemize}

\subsubsection{Folgerung}
\[K_s \leq K_v \leq K_d\]

\subsubsection{MiniMax-Theorem von Yao}
\[\forall p,q: min_j~(p^T \cdot M \cdot e_j) \leq K_v \leq max_i~(e_i^T \cdot M \cdot q)\]
Hiermit kann die worst-case-Laufzeit aller stochastischer Algorithmen durch die Laufzeit des schnellsten Deterministischen Algorithmus nach unten abgeschätzt werden.


\subsection{Spielbaumauswertung}
Ein binärer Spielbaum ist ein balancierter Binärbaum gerader Höhe \(2k\) mit Knotenwert \(x \in \{0,1\}\) und den Kindknoten \(y \in \{0,1\}\) und \(z \in \{0,1\}\). Es gilt:
\[Wert(x) = Wert(y) \downarrow Wert(z)\]

\subsubsection{Bestimme den Wurzelwert aus den Blattwerten}
\begin{minipage}{\textwidth}
WERT(x)
\begin{lstlisting}[frame=single,numbers=left]
Ermittle die Kindknoten x in stochastischer Reihenfolge
Ermittle WERT(y)
Falls (w=1) gib 0 aus, ansonsten gib (0 NOR WERT(z)) aus
\end{lstlisting}
\end{minipage}



\section{Algorithmen für Geometrische Probleme}

\subsection{Binäre Zerlegung der Ebene}

\subsubsection{Vorgehen}
Teile die affine Ebene \(A\) anhand einer Halbgeraden \(S_1\) in die Ebenen \(A_0\) und \(A_1\). Fahre rekursiv fort.

\subsubsection{Raumzerlegungsbaum}
Die Entstandenen Aufteilungen lassen sich über einen binären Raumzerlegungsbaum darstellen. Anwendung beispielsweise in der Computergrafik (Maleralgorithmus).
Ziel dabei: Möglichst kleine RZBs mit wenigen Zerlegungen.


\subsection{Binäre Zerlegung des Raums}
Folgender Algorithmus erzeugt binäre RZBs für den Raum:

\subsubsection{Eingabe}
Ein Polyeder \(P \subset \mathbb{R}^3\) sowie orientierte, planare, disjunkte Polygone \(P_1,...,P_n \subset \mathbb{R}^3\).
\\\\
\begin{minipage}{\textwidth}
BRZ
\begin{lstlisting}[frame=single,numbers=left]
k = 1
forall P_i {
	Bestimme Schnittmenge mit P
	Falls es Schittpunkte gibt: k++
}
l = 1
Falls es ein j gibt: Q_j zerlegt P:
	l += j
Wurzel = Q_l
Falls k >= 3
	Q = Schnittmenge von P und dem li. HR von Q_l
	li. Wurzelteilbaum = BRZ(Q,Q_1,...,Q_{k-1})
	Q = Schnittmenge von P und dem re. HR von Q_l
	ere. Wurzelteilbaum = BRZ(Q,Q_1,...,Q_{k-1})
Return Wurzel und Teilbaeume
\end{lstlisting}
\end{minipage}


\subsubsection{Laufzeit}
\(Z\) bezeichnet die Anzahl der von \(BRZ\) erzeugten Teilsegmente der \(P_i\). Es gilt:
\[\mathbb{E}\lbrack Z \rbrack \in \mathcal{O}(n^2)\]


\subsection{Konvexe Hüllen}
Wir fassen den \(\mathbb{R}^3\) als affinen Raum \(A\) auf und bezeichnen dessen Elemente als Punkte und ihre Differenzen als Vektoren. Die konvexe Hülle einer Teilmenge ist die kleinste konvexe Menge, die die Ausgangsmenge enthält\footnote{\url{http://de.wikipedia.org/wiki/Konvexe_H\%C3\%BClle}} (alle weiteren Elemente liegen in dem Raum, den die konvexe Hülle aufspannd).


\subsection{Dualität}

\subsubsection{Hyperebene}
Die Lösungsmenge einer linearen Gleichung
\[u^T \cdot x = 1, u \in \mathbb{R}^n\]
heißt Hyperebene von \(A\), d.h.
\[u* := \{x \in A~|u^T \cdot x = 1\}\]

\subsubsection{Halbebene}
Als \(u \in A\) wird der zu \(u*\), \(x*\) zum Punkt \(x\) duale Halbebene bezeichnet.

\subsubsection{Dualraum}
\[A* = \{x*~|~x \in A\}\]

\subsubsection{Halbraum}
Die Lösung der Ungleichung
\[u^T \cdot x \leq 1, u \ne 0,\]
bildet den Halbraum \(u^{\leq}\).


\subsection{Beziehungen zwischen Knoten, Kanten und Facetten}
Die Formeln gelten nicht nur für Polyeder, sondern für beliebige geschlossene Netze mit topologischen Geschlecht \(2\)., d.h. Netze, die bis auf Verbindungsformen eine Kugeloberfläche darstellen.

\subsubsection{Eulers Formel}
Für einen Polyeder mit \(v\) Knoten, \(e\) Kanten und \(f\) Seiten gilt:
\[v-e+f=2\]

\subsubsection{Triangulation von Polyedern}
Durch die Hinzunahme von Kanten kann ein Polyeder trianguliert werden. Werden \(k\) Kanten hinzugefügt gilt:
\[3(f+k) = 2(e+k\]
Daraus folgt der mittlere Knotengrad
\[\frac{2e}{v} \leq 6\]
und dazu die mittlere Kantenzahl pro Seite
\[\frac{2e}{f} \leq 6\]



\section{Bewegungsplanung bei unvollständiger Information}
\begin{itemize}
	\item Suche nach einer Lösung, über die auch zur Laufzeit nur Teilwissen bekannt ist
	\item Qualität der Ausgabe ist interessanter als die Laufzeit
	\item Es kann sein, dass keine oder keine eindeutige Lösung existiert
\end{itemize}


\subsection{Ausweg aus einem Labyrinth}
Wir betrachten ein Labyrinth \(L\) und einen Roboter \(R\) mit Tastsensor und Drehwinkelmessgerät.
\\\\
\begin{minipage}{\textwidth}
PLEDGE-Strategie
\begin{lstlisting}[frame=single,numbers=left]
while R in L {
	Gehe vorwaerts bis Wand kontaktiert wird
	while R in L OR Drehwinkel = 0 {
		Gehe links der Wand
	}
}
\end{lstlisting}
\end{minipage}


\subsection{Zum Ziel in unbekannter Umgebung}
Gegeben sind \(P_1,...P_n\) disjunkte Polygone, ein Roboter \(r\), ein Startpunkt \(s\) und ein Ziel \(z\).
\\\\
\begin{minipage}{\textwidth}
WANZE
\begin{lstlisting}[frame=single,numbers=left]
while r != z {
	Laufe in Richtung z bis r == z
			OR r nicht aus einem Polygon herauskommt
	Falls r != z {
		Suche den kuerzesten Punkt q an P_i zu z
		Laufe zu q
	}
}
\end{lstlisting}
\end{minipage}
Wanze terminiert.

\subsubsection{Universelles Steuerwort}
Jedes Steuerwort \(w \in \{z,l,r\}*\) entspricht einer Bewegung, die auf \(s\) angewendet den Endpunkt \(w(s)\) ergibt, der dieser Bewegung entspricht. Beispiel: \(w = zr^3zl^3z\)
\\\\
Satz: Es gibt ein universelles Steuerwort \(w\), das für alle Startpunkte zum gegebenen Ziel \(z\) führt. \(\rightarrow \) Da \(r\) alle endlichen Steuerworte erzeugen kann, erreicht er spätestens mit dem universellen sein Ziel. Ein Zielkompas genügt also zur Zielfindung.


\subsection{Behälterproblem}
Ziel: Zerlege eine Folge \(A := (a_1,...,a_m)\) in möglichst wenig Teilfolgen \(A_j\) mit einer bestimmten Größe \(h\) (Problem ist NP-hart).
\\\\
\begin{minipage}{\textwidth}
FIRST-FIT
\begin{lstlisting}[frame=single,numbers=left]
Forall i = 1,...,m {
	Fuege a_1 dem ersten Behaelter hinzu | a_i + A_j <= h
}
\end{lstlisting}
\end{minipage}
Die Laufzeit is in \(\mathcal{O}(n)\).

\subsubsection{Kompetivität}
Größe der Lösung eines Problems \(P\)
\begin{itemize}
	\item Optimaler Algorithmus: \(k_{opt}: \epsilon \rightarrow \mathbb{N}\)
	\item Korrektor Algorithmus \(A\): \(k_A: \epsilon \rightarrow \mathbb{N}\)
\end{itemize}
Es gilt:
\[k_A \leq a+c\cdot k_{opt}~(a,c \in \mathbb{R})\]
\(c\) bezeichnet den Kompetivitätsfaktor der Lösung.


\subsection{Türsuche}
Ziel: Finde die Tür an einer langen, unüberschaubaren Wand.
\\\\
\begin{minipage}{\textwidth}
Türsuche
\begin{lstlisting}[frame=single,numbers=left]
i = 1
while Tuer nicht gefunden {
	gehe i Meter in eine Richtung
	aendere Laufrichtung und gehe zurueck
	i++
}
\end{lstlisting}
\end{minipage}
Die Türsuche ist 9-kompetiv.


\subsection{Sternsuche}
Verallgemeinerung der Türsuche. Ziel: Finden des Ziels \(z\) vom Startpunkt \(s\) aus mit Hilfe von \(m\) wachsenden Halbgeraden.
\\\\
\begin{minipage}{\textwidth}
Sternsuche
\begin{lstlisting}[frame=single,numbers=left]
# berechne Halbgeraden
Forall i in N_0 {
	f_i = (m/(m-1))^i
}
i = 0
While z nicht gefunden {
	gehe f_i Einheiten auf H_i entlang und zurueck
	i++
}
\end{lstlisting}
\end{minipage}


\subsection{Suche in Polygonen}

\subsubsection{Definitionen}
\begin{itemize}
	\item Ein Polygon \(P\) heißt geschlossen, wenn gilt \(p_m = p_1\).
	\item Ein Polygone \(P\) heißt einfach, wenn kein Punkt von \(P\) in zwei Kanten liegt.
\end{itemize}
Es gibt keine kompetitive Strategie.

\subsubsection{Baum der kürzesten Wege}
\begin{itemize}
	\item Die kürzesten Wege \(s\) zu den Ecken von \(P\) bilden den Baum der kürzesten Wege (BkW) von \(P\) und \(s\)
	\item Absuchen der Wege zu den Blättern per Sternsuche
	\item Speichern der bereits erreichten Punkte als Zwischenstopps für spätere Punkte
\end{itemize}



\section{Lineare Programmierung}
\textbf{Ziel:} Maximierung linearer Funktionen mit linearen Nebenbedingungen, beispielsweise zur Bestimmung des maximalen FLusses in einem Netzwerk oder um das MiniMax-Theorem zu beweisen.

\subsection{Lineares Programm}
Die lineare Ungleichung
\[y := \upsilon^T \cdot x + u \geq 0\]
beschreibt den Halbraum mit Normalenvektor \(\upsilon\).

\subsubsection{Konvexer Polyeder}
Die Nebenbedingungen
\[y_i := a_i^T \cdot x + a_i \geq 0,~i = 1,...,l\]
bilden ein konvexes Polygon \(s\), das in der linearen Programmierung \textit{Simplex} genannt wird. Das gesuchte Maximum, das durch die Nebenbedingungen begrenzt wird, befindet sich innerhalb des Simplex.
\\\\
\textbf{Ziel:} Maximierung einer linearen Zielfunktion über dem Simplex \(s\):
\[z := z^T \cdot x = max!\]
\[y := A\cdot x + a \geq 0\]

\subsubsection{Normalform des linearen Programms}
\[z = c^T\cdot \bar{y} + c \stackrel{!}{=} max\]
\[y' \geq 0\]
\[y'' = B \cdot y' + b \geq 0\]

\[\begin{array}{c|ccc|c|}
	& & y' \geq 0 & & 1 \\
	\hline
	& & & & \\
	y''= & & B & & b \\
	& & & & \\
	\hline
	z= & & c^T & & c \\
	\hline
\end{array}\]
\(c\) wird maximiert.


\subsection{Eckentausch}
\textbf{Ziel:} Um \(z\) zu maximieren, machen wir sukzessive neue \(y_i\) zu neuen Koordinaten, so dass der Ursprung von Ecke zu Ecke wandert und der Wert von \(z\) im Ursprung wächst.
\\\\
\textbf{Vorgehen}: Tausche immer eine Koordinate von \(y'\) mit einer von \(y''\).
\[\begin{pmatrix}
	a_{11}v_1 & ... &a_{1n}v_n & u_1\\
	.   &		.	& .   & . \\
	.   &		.	& .   & . \\
	.   &		.	& .   & . \\
	a_{m1}v_1 & . & a_{mn}v_n & u_m
\end{pmatrix}\]
Ist \(a_{rs} \ne 0\) können \(u_r\) und \(v_s\) getauscht werden. Ein beliebiges \(a_{rs}\) fungiert als Pivotelement. 
\\\\\\
\begin{minipage}{\textwidth}
AUSTAUSCH(A, r, s)
\begin{lstlisting}[frame=single,numbers=left,mathescape]
Forall $i \ne r$, $j \ne s$ {
	$a_{ij}' = a_{ij} - \frac{a_{is} \cdot a_{rj}}{a_{rs}}$
}
# Pivotzeile
Forall $i == r$, $j \ne s$ {
	$a_{ij}' = -\frac{a_{ij}}{a_{rs}}$
}
# Pivotspalte
Forall $i \ne r$, $j == s$ {
	$a_{ij}' = \frac{a_{ij}}{a_{rs}}$
}
# Pivot
Forall $i == r$, $j == s$ {
	$a_{ij}' = \frac{1}{a_{rs}}$
}
\end{lstlisting}
\end{minipage}


\subsection{Der Simplexalgorithmus}
\textbf{Ausgangspunkt:} Ein lineares Programm in Normalform
\[z = c^T \cdot x + c = max!,\]
\[x \geq 0,\]
\[B \cdot x + b \geq 0,\]
ausführlich:
\[\begin{array}{c|ccc|c|}
	& x_1 & ... & x_n & 1 \\
	\hline
	y_1= & b_{11} & ... & b_{1n} & b_1 \\
	\vdots & \vdots & & \vdots & \vdots \\
	y_m= & b_{m1} & ... & b_{mn} & b_n \\
	\hline
	z= & c_1 & ... & c_n & c \\
	\hline
\end{array}\]
\\\\
\textbf{Vorgehen:} Iteratives Tauschen von \(y_r\) mit \(x_s\).
\\\\\\
\begin{minipage}{\textwidth}
SIMPLEX
\begin{lstlisting}[frame=single,numbers=left,mathescape]
# Bringe Problem in Normalform
Forall Bedingungen {
	Formuliere Bedingung als Ungleichung in Matrixzeile
	Falls Bedingung obere Schranke hat {
		invertiere Ungleichung
	}
}

# Tausche
While moeglich {
	Waehle kleinsten Matrixwert als Pivotelement
	Forall Zeilen {
		Ermittle $\frac{b_i}{b_is}$
		x = davon groesster, noch negativen Wert
	}
	Tausche Spalte(Pivotelement) mit Zeile(x)
}
\end{lstlisting}
\end{minipage}


\subsection{Berechnung der Normalform}
\begin{itemize}
	\item Für die Überführung eines linearen Programms in die Normalform muss eine Ecke des Simplex zum Ursprung gemacht werden
	\item Problem: Im Allgemeinen sind die Ecken des Simplex nicht bekannt
	\item Es sind allerdings einer oder mehrere Punkte bekannt, die zum Ursprung gemacht werden können
	\item \textbf{Vorgehen}
	\begin{enumerate}
		\item Tauschen von \(y_r\) mit \(x_s\) auf der Hauptdiagonalen. Der Ursprung wandert auf einer Koordinatenachse
		\item Streichen der getauschten Zeile
	\end{enumerate}
\end{itemize}


\subsection{Flussmaximierung}
Die Suche nach einem maximalen Fluss in einerm Flussnetzwerk kann als lineares Programm angesehen werden.

\textbf{Gegeben:} Gerichteter Graph mit Kapazitätsbeschriftung.
\\\\
Daraus ergibt sich das lineare Programm:
\[z = x_1 + x_2 = max!\]
Nebenbedingungen:
\begin{itemize}
	\item \textbf{Flusserhaltung}
	\begin{itemize}
		\item Für jeden Knoten die Summe der aus- und eingehenden Flüsse: z.B. \(x_1-x_3-x_4 \geq 0\)
		\item Für jeden Knoten die negierten aus- und eingehenden Flüsse: z.B. \(-x_1+x_3+x_4 \geq 0\)
	\end{itemize}
	\item \textbf{Kapazitätsbeschränkung}
	\begin{itemize}
		\item Für alle Kanten die Beschränkung des Flusses: z.B. \(5-x_1 \geq 0\)
		\item An allen Kanten muss der Fluss positiv sein: z.B. \(x_1 \geq 0\)
	\end{itemize}
\end{itemize}


\subsection{Duale lineare Programme}
Das lineare Programm
\[x \geq 0\]
\[B\cdot x + b \geq 0\]
\[c^T \cdot x + c = max!\]
wird durch die Matrix \(\mathbb{B} := \begin{pmatrix} B & b \\ c^T & c\end{pmatrix}\) repräsentiert. Durch Eckentausch kann sie auf eine Normalform \(\overline{\mathbb{B}}\) gebracht werden.

\subsubsection{Dualitätsgesetz}
Das lineare Programm
\[y \geq 0\]
\[B^T \cdot y + c \leq 0\]
\[b^t \cdot y + c = min!\]
hat die Normalform \(\overline{\mathbb{B}}^T\), die Lösung \(\overline{y}=0\) und den Minimalwert \(\overline{c}\).
\\\\
\textbf{Definition:} Die beiden linearen Programme heißen dual zueinander.
\\\\
\textbf{Bemerkung:} Das zweite Programm kann umgeschrieben und mit \textit{SIMPLEX} gelöst werden. Gleichzeitig löst man damit das erste Programm. Es ist das Lösen des \textit{primalen Programms} in dualer Form.


\subsection{Beweis des MiniMax-Theorems}
Mit Hilfe des Dualitätssatzes für lineare Programme kann das MiniMax-Theorem
\[max(x \in W_M)~min(y \in W_n)~x^T\cdot A\cdot y = min(y \in W_n)~max(x \in W_m)~x^T\cdot A \cdot y\]
bewiesen werden. Auf Grund des SIMPLEX-Algorithmus ist es äquivalent zu
\[max(x)~min(i)~x^T\cdot A \cdot e_j = min(y)~max(i)~e_i^T\cdot A \cdot y\]

\subsubsection{Linke Seite}
Auf der linken Seite wird
\[x_0 := min(i)~x^T\cdot A \cdot e_j\]
maximiert. Da \(x_0\) mit \(x\) wächst erhält man das lineare Programm
\\\\
\[\begin{array}{|cc|c|}
x & x_1 & 1 \\
\hline
A^T & -b & 0 \\
-a^T & 0 & 1 \\
\hline
0^T & 1 & 0 \\
\hline
\end{array}\]

\subsubsection{Rechte Seite}
Analog wird die rechte Seite
\[max(i)~e_i^T\cdot A \cdot y\]
minimiert. Man erhält das lineare Programm
\\\\
\[\begin{array}{|cc|c|}
y & x_0 & 1 \\
\hline
A & -a & 0 \\
-b^T & 0 & 1 \\
\hline
0^T & 1 & 0 \\
\hline
\end{array}\]

\subsubsection{Folgerung}
Da die rechte Seite dual zur linken Seite, folgt das MinMix-Theorem.


\subsection{Ausgleichen mit der Maximumsnorm}
Sei
\[Ax = a\]
ein überbestimmtes Gleichungssystem, d.h. für alle \(x\) ist das Residuum
\[r := \begin{bmatrix} r_1 \\ \vdots \\ r_n \end{bmatrix} := Ax - a \ne 0.\]
\textbf{Ziel:} Minimieren von
\[r := \parallel r \parallel_{\infty} := max(i)~|r_i|\]
mit Hilfe eines linearen Programms
\[-A\overline{x} + ax_0 + e \geq 0\]
\[A\overline{x} - ax_0 + e \geq 0\]
\[x_0 = max!\]

\subsubsection{Vorgehen zur Berechnung}
\textbf{Gegeben:} Lineares, überbestimmtes Gleichungssystem
\begin{enumerate}
	\item Aufstellen des linearen Programms
	\begin{enumerate}
		\item Formulieren der Nebenbedingungen und der negierten Nebenbedingungen
		\item Nebenbedingungen im linearen Programm gleich \(1\) setzen
	\end{enumerate}
	\item Berechnen des Maximums nach dem SIMPLEX-Algorithmus
	\item Berechnung der Normalform
	\item Berechnung von \(x_1\) aus \(r\) (\(z = x_0\))
\end{enumerate}


\subsection{Aufwand}
\begin{itemize}
	\item Worst-Case-Laufzeit: \(\Omega(m^{\frac{n}{2}})\)
	\item Laufzeit in der Praxis: \(\mathcal{O}(m^2n)\)
	\item Lineare Programme sind NP-hart (Überführung in Rücksackproblem möglich)
\end{itemize}



