\section{Appendix A: Algorithmen und Erklärungen}

Aufstellung und Erläuterung aller Algorithmen der Vorlesung Vorlesung "`Algorithmen II"' aus dem Wintersemester 2014.\footnote{\url{http://geom.ivd.kit.edu/ws14_algo2.php}}

\subsection{Algorithmus von Ford und Fulkerson}

\begin{algorithm}[H]
	\caption{Ford-Fulkerson}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$F(G,k,q,s)$}
	\Output{Ein maximaler Fluß $f$}
	\BlankLine

	$f \longleftarrow 0$

	\While{Es gibt einen Pfad $q \rightarrow s$ in $G_f$} {
		Erhöhe $f$ über diesem maximal
	}
\end{algorithm}

\subsection{Edmonds-Karp.Algorithmus}
	Erhöht man den Fluß in Ford-Fulkerson imer längs eines kürzesten Pfads (Breitensuche), erhält man den Edmonds-Karp-Algorithmus
	
\subsection{Die Präfluss-Pusch-Methode}
\begin{algorithm}[H]
	\caption{Push}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$x,y$}
	\Output{}
	\BlankLine

	$d \longleftarrow \min{ü(x), k_f(x,y)}$ \newline
	$f(x,y) \longleftarrow f(x,y) +d$ \newline
	$ü(x) \longleftarrow ü(x) -d $ \newline
	$ü(y) \longleftarrow ü(y) +d$ \newline
\end{algorithm}

Push ist nur erlaubt wenn 
	\begin{itemize}
		\item $ü(x) > 0, x \in V \setminus {q,s}$
		\item $(x,y) \in E_f$
		\item $h(x) - h(y) = 1$
	\end{itemize} 


\begin{algorithm}[H]
	\caption{Lifte}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$x$}
	\Output{}
	\BlankLine

	$h(x) := 1+ \min_{(x,y) \in E_f}{h(y}$
\end{algorithm}

Lifte ist nur erlaubt wenn 
	\begin{itemize}
		\item $x \in V \setminus {q,s}$
		\item $ü(x) > 0$
		\item $h(x) \leqslant \min_{(x,y) \in E_f}{h(y)}$
	\end{itemize} 


\begin{algorithm}[H]
	\caption{Präfluss-Pusch}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$F(G,k,q,s$}
	\Output{Maximaler Fluss $f$}
	\BlankLine

	\For{alle $ x,y \in V $ }{
	$ h(x)  \leftarrow \begin{cases}|V| & x=q \\ 0 & \text{sonst}\end{cases}$ \newline
	$ f(x,y)  \leftarrow \begin{cases}k(x,y) & x=q \\ 0 & \text{sonst}\end{cases}$}
	\While{Es gibt erlaubte Push oder Lifte Operationen} {Führe beliebig Push oder Lifte aus}
\end{algorithm}

\subsection{"`An die Spitze"' Präfluss-Push-Algorithmus}

\begin{algorithm}[H]
	\caption{Leere}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$x$}
	\Output{}
	\BlankLine

	\While{$ü(x)>0$}{	
		\If{$i_x > 0$}{
			$y \longleftarrow n_x(i_x)$ \newline
			\If{$(x,y) \text{puschbar}$}{
				$Pusch(x,y)$}
			\Else{
				$i_x \longleftarrow i_x -1$}
			}
		\Else{	$Lifte(x)$ \newline
				$i_x \longleftarrow Grad(x)$}
			
		}	
\end{algorithm}

\begin{algorithm}[H]
	\caption{An die Spitze}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$F(G,k,q,s)$}
	\Output{Einen maximalen Fluss f}
	\BlankLine
	
	Initialisiere f und h wie in Präfluss-Pusch \newline
	Generie L \newline
	$x \longleftarrow Kopf(L)$ \newline
	\For{$\forall x \in V$}{
		$i_x \longleftarrow Grad(x)$}
	\While{$x \ne Nil$ }{	
		$h_{alt} \longleftarrow h(x)$ \newline
		$Leere(x)$ \newline
		\If{$h_{alt} < h(x)$}{
			Setze x an die Spitze von L
		}	
		$x \longleftarrow \text{Nachfolger von x in L}$
		}
\end{algorithm}

\subsection{Paaren in allgemeinen Graphen}
\begin{algorithm}[H]
	\caption{Paare}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{bipartiter Graph $(V_1 \stackrel{\cdot}{\cup} V_2, E)$}
	\Output{Maximale Paarung P}
	\BlankLine
	
	$V \longleftarrow V_1 \cup V_2 \cup \{ q,s \}$ \newline
	$\hat{E} \longleftarrow \{ q \} \times V_1 \cup E \cup V_2 \times \{ s \} $ \newline
	$k \longleftarrow \begin{cases}1 & e \in \hat{E} \\ 0 & \text{sonst}\end{cases}$ \newline
	$f \longleftarrow Ford-Fulkerson( F(V, \hat{E} ),h,q,s)) $ \newline
	$P \longleftarrow \{ e \in E | f(e) = 1 \} $
\end{algorithm}


\subsection{Sortieren durch stochastisches Teilen}
\begin{algorithm}[H]
	\caption{Quicksort}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$ S : = \{ s_1, ... , s_n \} $ 	mit paarweise verschiedenen 	$ s_i \in \mathbb{Z} $ 	}
	\Output{$( \delta_1, ... , \delta_n)$ mit $\delta_1 < ... < \delta_n$ und $\{ \delta_1, ... , \delta_n \} = S $}
	\BlankLine
	
	\While{ S $\ne \emptyset$} {
		Wähle ein zufälliges Pivotelement $ y \in S $ \newline
		Zerlege $S \setminus \{ y \} $ 	in 	$  s_1 $ und $ s_2 $ , so dass 	$ s_1 < y < s_2 $ \newline
		Gib $ ( Quicksort(s_1 , y ),Quicksort(s_2))$ aus \newline
		}
\end{algorithm}

\subsection{Minimaler Schnitt}
\begin{algorithm}[H]
	\caption{Schnitt}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$ (V,E) $ ein ungerichteter Multigraph}
	\Output{Ein Schnitt S}
	\BlankLine
	
	\While{ $|V| \ge 3$} {
		Wähle ein zufälliges Kante $ (x,y) \ in E $ \newline
		Entferne Alle $(x,y)$ aus $E$ \newline
		Verschmelte x mit y \newline
		}
	Gib $S:=E$ aus
\end{algorithm}

\begin{algorithm}[H]
	\caption{Finde}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$S:= \{ s_1 , ... , s_n \} \subset \mathbb{M}$}
	\Output{$ \delta_k$, wobei $\delta_1, ... , \delta_n \in S$ und $\delta_1 < ... < \delta_n$}
	\BlankLine
	
	Wähle y zufällig aus S \newline
	$S_1 \longleftarrow \{ x \in S | x < y \} $\newline
	$S_2 \longleftarrow \{ x \in S | x > y \} $ \newline
	\If{ $|S_1| = k-1$}{ gib y aus}
	\Else{
		\If{$|S_1| > k-1$}{$Finde(S_1,k)$}
		\Else{$Finde(S_2, k-|S_1|-1)$}
		}
\end{algorithm}

\subsection{Spielbaumauswertung}
\begin{algorithm}[H]
	\caption{Wert}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{x Knoten eines binären Spielbaums}
	\Output{$Wert(x)$}
	\BlankLine
	
	Wähle y zufällig aus S \newline
	$(y,z) \longleftarrow $ Paare der Kinder von x in zufälliger Reihenfolge\newline
	$W \longleftarrow Wert(y)$ \newline
	\If{ $w=1$}{gib 0 aus}
	\Else{
		gib 0 XOR Wert(z) aus}
\end{algorithm}


\subsection{Binäre Zerlegung des Raum}
Rekursive Zerlegung eines Polyeders des \(\mathbb{R}^3\) anhand einiger Polygone. Pro Iterationsschritt wird jeweils ein Polygon bestimmt (bevorzugt eines, das den Polyeder komplett zerlegt). Dieses teilt den Polyeder in einen linken und einen rechten Teilpolyeder, die jeweils weiter zerlegt werden.

\begin{algorithm}[H]
	\caption{BRZ}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{Ein Polyeder $P \subset \mathbb{R}^3$; orientierte, planare, disjunkte Polygone $P_1,...,P_n \subset \mathbb{R}^3$}
	\Output{Ein $RBZ$ für $P_1,...,P_n$}
	\BlankLine

	$k \longleftarrow 1$
	\BlankLine
	\tcc{Sortiere Polygonenteile aus, die außerhalb von $P$ liegen (Clipping)}
	\For {$i=1,...,n$}{
		$Q_k \longleftarrow P_1 \cap P$
		\If {$Q_k \neq \emptyset$} {
			$k \longleftarrow k + 1$
		}
	}

	$l \longleftarrow 1$

	\BlankLine
	\tcc{Falls ein Polygon $P$ komplett zerteilt, nehme dieses als Trennelement. Anderenfalls nehme das erste in der Liste}
	\If{$\exists~j: Q_j~zerlegt~P~vollstaendig$}{
		$l \longleftarrow j$
	}

	$Wurzel \longleftarrow Q_l$
	\BlankLine
	\tcc{Teile $P$}
	\If{$k \geq 3$}{
		$Q \longleftarrow P \cap li.~HR~von~Q_l$\newline
		$li. Wurzelteilbaum \longleftarrow BRZ(Q,Q_1,...,Q_{k-1})$\newline
		$Q \longleftarrow P \cap re.~HR~von~Q_l$\newline
		$re. Wurzelteilbaum \longleftarrow BRZ(Q,Q_1,...,Q_{k-1})$
	}

	\BlankLine
	\Return{Wurzel mit ihren Teilbaeumen}

\end{algorithm}


\subsection{Konstruktion konvexer Hüllen}
Die konvexe Hülle einer Teilmenge ist die kleinste konvexe Menge, die die Ausgangsmenge enthält.\footnote{\url{http://de.wikipedia.org/wiki/Konvexe_Hülle}}

\subsubsection{Annahmen}
\begin{itemize}
	\item Die Reiehenfolge der \(p_i\) sei gleichverteilt zufällig
	\item Keine vier der Ebenen \(p_i^{*}\) schneiden sich in einem Punkt
	\item Jeder Knoten hat den Grad \(3\)
\end{itemize}

\begin{algorithm}[H]
	\caption{BRZ}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{Punktmenge $P=(p_1,..,p_n) \cap A^3$}
	\Output{$\lbrack P \rbrack$}
	\BlankLine

	\tcc{Verschiebe $P$, so dass der Ursprung innerhalb der Konvexen Hülle liegt}
	$v \longleftarrow 0 - \sum_i \frac{p_i}{n}$\newline
	$P \longleftarrow P + v$
	\BlankLine

	\tcc{Schritt 2}
	$V \longleftarrow$ Knotenliste von $p_1^{\leq} \cap ... \cap p_4^{\leq}$\newline
	\For{$j > i$} {
		\eIf{$p_j^{\leq} \supset V$}{
			Entferne $p_j$ aus $P$\newline
			Aktualisiere "`gedanklich"' alle Indizes $k>j$
		}{
			Verknüpfe $p_j$ bidirektional mit einem $w_j \in V_4 \backslash p_j^{\leq}$
		}
	}
	\BlankLine

	\tcc{Schritt 3}
	\For{i = 5,...,n}{
		Durchlaufe $V$ von $w_i$ aus und setze dabei:\newline
			$N_i \longleftarrow \{ Schnittpunkte~der~Kanten~mit~p_i^{*}\}$\newline
			$W_i \longleftarrow V \cap p_i^{>}$\newline
			$V \longleftarrow (V \cup N_i) \backslash W_i$\newline
		\BlankLine
		\For{$j>i$ mit $w_j \in W_i$}{
			\eIf{$N_i \subset p_j^{\leq}$}{
				Entferne $P_j$ aus $P$\newline
				Aktualisiere "`gedanklich"' alle Indizes
			}{
				Verknüpfe $p_j$ neu mit einem $w_j \in N_i \cap p_j^{>}$
			}
		}
	}
	\BlankLine

	\Return{Verschobene Polarmenge $Q_P$}

\end{algorithm}


\subsection{Pledge Startegie}

Findet einen Weg aus einem Labyrinth.\\
Der Roboter kann erkennen, wenn er das Labyrinth verlassen hat.\\
Bei jeder Drehung wird die Änderung zum Startwinkel $ \varphi $ aktualisiert.\\

\begin{algorithm}[H]
	\caption{Pledge Strategie}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{Labyrinth $L$ und Roboter $R$}
	\Output{Weg aus dem Labyrinth}
	\BlankLine

	$\varphi \leftarrow 0$
	
	\While{$ R \in L $}{	
		gehe vorwärts bis zu einer Wand.\\
		gehe links der Wand entlang bis $ R \not\in L \text{ oder } \varphi = 0 $	
		}
\end{algorithm}


\subsection{Wanze}

Findet einen Ziel in einer Umgebung mit Hindernissen.\\

\begin{algorithm}[H]
	\caption{Wanze}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$P_1 , ... , P_n$ disjunkte, einfache geschlossene Polygone.\\
	$ S, Z $ Start und Ziel $\in A^2 \setminus P$.\\
	Roboter $R$ der seine eigene Position $r$ kennt.}
	\Output{Weg von $S$ nach $Z$.}
	\BlankLine
	
	\While{$r \ne Z$}{	
		gehe Richtung $Z$ bis $r = Z$ oder $r \in P$\\	
		\If{$r \ne Z$} {
                    umlaufe $P_i$, suche dabei $q \in argmin || x - z ||_2 , x \in P_i$ \\
                    (die Stelle auf dem umlaufenen Polygon mit minimalem Abstand zu $Z$.)\\
                    gehe zu $q$
		}
    }
\end{algorithm}

\subsection{Geometrische Algorithmen - Türsuche 1}

Roboter steht vor einer langen Wand und sucht die Tür.\\


\begin{algorithm}[H]
	\caption{Türsuche 1}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}


	$i \leftarrow 1$
	
	\While{Tür noch nicht gefunden}{	
		gehe $i$ Meter der Wand entlang.\\
		gehe i Meter zurück (ändert die Laufrichtung)\\
		$ i \leftarrow i+1$\\
		}
\end{algorithm}

Weglänge: Ist die Tür n + (0,1) Meter vom Ausgangspunkt entfernt, gilt:\\
Weglänge $\ge 2 \cdot 1 + 2 \cdot 2 + ... + 2n +n = O(n^2)$.\\
$\Rightarrow$ Türsuche 1 ist nicht kompetetiv.


\subsection{Geometrische Algorithmen - Türsuche 2}

Roboter steht vor einer langen Wand und sucht die Tür.\\


\begin{algorithm}[H]
	\caption{Türsuche 2}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}


	$i \leftarrow 1$
	
	\While{Tür noch nicht gefunden}{	
		gehe $i$ Meter der Wand entlang.\\
		gehe i Meter zurück (ändert die Laufrichtung)\\
		$ i \leftarrow 2i$\\
		}
\end{algorithm}

Weglänge: Ist die Tür $2^{n+\delta}$ Meter vom Ausgangspunkt entfernt, gilt:\\
Weglänge $\le 2 \sum\limits_{i=0}^{n+1} 2^i + 2^{n+\delta} \le 2 ^{n+3+\delta} + 2^{n+\delta} \le 9 \cdot 2^{n+\delta}$.\\
$\Rightarrow$ Türsuche 2 ist 9-kompetetiv.


\subsection{Geometrische Algorithmen - Sternsuche}

Roboter steht in der Mitte eines Kreuzes aus Halbgeraden (beginnen in S).\\

\begin{algorithm}[H]
	\caption{Sternsuche}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
        
        \Input{$S$ Startpunkt, $Z$ Ziel, $m$ Halbgeraden, startend in S}
        $\forall i \in \mathbb{N}_0 : f_i \leftarrow \left(\frac{m}{m-1}\right)^i$

	$i \leftarrow 0$
	
	\While{Z noch nicht gefunden}{	
		gehe $f_i$ Meter auf $H_{i \text{ mod } m}$ entlang.\\
		gehe zurück zu $S$\\
		$ i \leftarrow i+1$\\
		}
\end{algorithm}

$\Rightarrow$ Sternsuche ist kompetetiv mit factor $c = 2m \left(\frac{m}{m-1}\right)^{m-1}+1$


\subsection{Zufallsgesteuerte Optimierung}

\subsection{Algorithmus von de Casteljau}
Der Algorithmus von de Casteljau ermöglicht die effiziente Berechnung einer beliebig genauen Näherungsdarstellung von Bézierkurven durch einen Polygonzug.\footnote{http://de.wikipedia.org/wiki/De-Casteljau-Algorithmus}

Der de Casteljau-Algorithmus angewendet auf ein Polygon \(B_0^0\) ist die Konkatenation von \(B_0^1\) und \(B_1^1\): \(C(B_0^0,t) := B_0^1 B_1^1\).

\begin{algorithm}[H]
	\caption{de Casteljau}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$b_0^0,...,b_n^0 \subset \mathbb{R}^d; t \in \mathbb{R}$}
	\Output{$b_0^0,...,b_0^n; b_0^n,...b_n^0 \subset \mathbb{R}^d$}
	\BlankLine

	\For{$k=1,...,n$}{
		\For{$i=0,...,n-k$}{
			$b_i^k \longleftarrow b_i^{k-1} \cdot (1-t) + b_{i+1}^{k-1} \cdot t$
		}
	}
\end{algorithm}


\subsection{Naive Textsuche}
Im Folgenden ist \(A\) ein Alphabet, \(t = t_1,...,t_n \in A^n\) ein Text und \(s = s_1,...,s_m \in A^m\) mit \(m<n\) ein Suchtext.

Der einfachste Algorithmus besteht darin, ein so genanntes Suchfenster von der Länge der Suchmaske über den Text zu schieben. In jeder Position der Suchmaske werden die Symbole der Maske mit denen des darunterliegenden Textes verglichen. Wenn ein nicht übereinstimmendes Symbol gefunden wird, wird das Fenster um eine Position verschoben, und erneut ein Vergleich angestellt; wenn alle Symbole im Fenster übereinstimmen, ist die Suchmaske gefunden worden. Der Algorithmus endet, wenn der ganze Text vom Fenster abgesucht worden ist.\footnote{\url{http://de.wikipedia.org/wiki/String-Matching-Algorithmus\#Naiver_Algorithmus}}

\begin{algorithm}[H]
	\caption{Naive Suche}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$A,t,s$}
	\Output{Kleinstes $t_{i+1},...,t_{i+m} = s$}
	\BlankLine

	$i \longleftarrow 0$\newline
	\While{$i\leq n-m$}{
		$j \longleftarrow m$\newline
		\While{$j>0$ und $s_j=t_{i+j}$}{
			$j \longleftarrow j-1$
		}
		\BlankLine
		\eIf{$j=0$}{
			\Return{$i$}
		}{
			$i \longleftarrow i+1$
		}
	}
\end{algorithm}
Laufzeit in \(\mathcal{O}(n\cdot m)\), wenn der ganze Text abgesucht werden muss.

\subsection{Algorithmus von Boyer und Moore}
Das Muster wird am Anfang linksbündig unter den Text geschrieben und dann von rechts nach links Zeichen für Zeichen mit dem Text verglichen. Sobald ein Mismatch auftritt, berechnen zwei Heuristiken, wie weit das Suchmuster nach rechts verschoben werden kann.\footnote{\url{http://de.wikipedia.org/wiki/Boyer-Moore-Algorithmus}}

Es kommt vor, dass die beiden Heuristiken unterschiedliche Verschiebungen berechnen. Der Algorithmus wählt immer das Maximum der beiden Vorschläge, um das Muster nach rechts zu verschieben.

\subsubsection{Bad-Character-Heuristik}
Stimmt beim Vergleich des Musters mit dem Text von rechts nach links ein Zeichen des Musters nicht mit dem Zeichen des Textes überein („Bad-Character“), wird im Muster nach dem letzten Vorkommen dieses Bad-Characters gesucht und das Muster soweit verschoben, bis beide Buchstaben übereinander liegen. Existiert dieser Bad-Character nicht im Muster, wird das Muster um seine volle Länge nach rechts verschoben. Es kann vorkommen, dass die Bad-Character-Heuristik eine Verschiebung des Musters nach links vorschlägt. In diesem Fall wird um eine Position nach rechts geschoben.

Der Boyer-Moore-Algorithmus arbeitet am effizientesten, wenn er ein Zeichen vorfindet, das im Suchmuster nicht vorkommt. Die Bad-Character-Regel kommt dann zum Tragen. Dies ist sehr wahrscheinlich bei einem relativ kleinen Muster und einem großen Alphabet, was ihn für einen solchen Fall besonders geeignet macht. In diesem Fall arbeitet der Algorithmus mit einer Effizienz von \(\mathcal{O}(\frac{n}{m})\) Vergleichen.

\subsubsection{Good-Suffix-Heuristik}
Stimmt beim Vergleich des Musters mit dem Text von rechts nach links ein Suffix des Musters mit dem Text überein und tritt danach aber ein Mismatch auf, wird das Muster soweit nach rechts geschoben, bis ein Teilwort des Musters wieder auf das Suffix passt. Existiert das Suffix kein zweites Mal im Muster, wird das Muster um seine volle Länge nach rechts verschoben.

\paragraph{Vorberechnung des größten, echten Präsuffixes pro Zeichen im Suchwort}
Ein Präfix eines Wortes \(w\), das zugleich ein Suffix von \(w\) ist, nennen wir \textit{Präsuffix} von \(w\). Weiter sei \(\gamma(j) := | geps(w_j)|\).

\begin{algorithm}[H]
	\caption{$\gamma$}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$s_1,...,s_m$}
	\Output{$\gamma(0,...,m-1$}
	\BlankLine

	$\gamma(m-1) \longleftarrow 0$\newline
	\For{i=m-1,...,1}{
		$j \longleftarrow m - \gamma(i)$\newline
		\While{$s_i \ne s_j$ und $m \ne j$}{
			$j \longleftarrow m - \gamma(i)$
		}
	}
	\BlankLine

	\eIf{$s_i = s_j$}{
		$\gamma(i-1) \longleftarrow m - j+1$
	}{
		$\gamma(i-1) \longleftarrow 0$
	}
\end{algorithm}

\paragraph{Berechnung der Heuristik}
Die Heuristik berechnet für jedes Zeichen des Suchwort, wie weit dieses verschoben werden kann. Grundlage ist dabei die Gamma-Funktion, welche für jedes Zeichen des Suchworts die Länge des größten, echten Präsuffixes angibt.

\begin{algorithm}[H]
	\caption{$\gamma$}
	\SetKwData{Left}{left}\SetKwData{This}{this}\SetKwData{Up}{up}
	\SetKwFunction{Union}{Union}\SetKwFunction{FindCompress}{FindCompress}
	\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}

	\Input{$\gamma(0,...,m-1)$}
	\Output{$\sigma(1,...,m)$}
	\BlankLine

	\For{$j = 1,...,m$}{
		$\sigma(j) \longleftarrow m-\gamma(0)$
	}
	\BlankLine

	\For{$i=0,...,m-1$}{
		$k \longleftarrow m - \gamma(i) - i$\newline
		$j \longleftarrow m - \gamma(i)$
		\If{$\sigma(j) > k$}{
			$\sigma(j) \longleftarrow k$
		}
	}
\end{algorithm}

