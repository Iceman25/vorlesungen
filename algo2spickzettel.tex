\section{Appendix A: Spickzettel}

\subsection{Flussnetzwerke}

\subsubsection{Definitionen}
\begin{itemize}
	\item Ein Flussnetzwerk besteht aus einer Kapazitätsfunktion \(k\), einem gerichteten Graph \(G\), einer Quelle \(q\) und einer Senke \(s\)
	\item \textbf{Eigenschaften eines Flusses \(f:V^2 \rightarrow \mathbb{R}\)}
	\begin{enumerate}
		\item \(f \leq k\) (der Fluss kann nicht höher sein als die Kantenkapazität)
		\item \(\forall x,y \in V:~f(x,y) = -f(y,x)\) (keine negativen Flüsse)
		\item \(\forall x \in V \setminus \{ q,s\}:~0 = \sum f(x,V) = \sum_{y \in V} f(x,y)\) (Flusserhalt)
	\end{enumerate}
	\item Wert eines Flusses: \(W_f = \sum f(q,V)\)
	\item Residualgraph: Die Kanten \(f(e) < k(e)~|~e \in E\) bilden den Residualgraph \(G_f = G(V,E_f)\)
\end{itemize}

\subsubsection{Maximaler Fluss}
Der maximale Fluss ist
\begin{itemize}
	\item die Summe der von \(q\) ausgehenden Kanten,
	\item bei \(s\) ankommenden genutzten Kapazitäten oder
	\item der minimale Schnitt durch das Netzwerk.
\end{itemize}

\subsubsection{Algorithmus von Ford und Fulkerson}
\begin{itemize}
	\item Terminiert Ford-Fulkerson, so ist \(f\) maximal
	\item Aufwand: \(\mathcal{O}(|E| \cdot max\{W_f~|~f~Fluss~in~F\})\), denn ein Pfad \(q \rightarrow^{*} s\) kann in \(|E|\) Schritten gefunden werden
\end{itemize}

\subsubsection{Algorithmus von Edmonds und Karp}
Erhöhe den Fluss in \textit{FORD-FULKERSON} immer längs eines kürzesten Pfads (Breitensuche). Aufwand: \(\mathcal{O} (|E|^2 \cdot |V|)\).

\subsubsection{Präfluss-Pusch-Methode}
Jeder Knoten erhält zusätzlich eine Höhe und ein Reservoir, um vorübergehend beliebig viel Fluß speichern zu können. Aufwand: \(\mathcal{O} (|V|^2 \cdot |E|)\).

\subsubsection{Move-to-Front-Algorithmus}
Durch eine strukturierte Abarbeitung der Operationen wird \textit{Präfluss-Pusch} beschleunigt. Aufwand: \(\mathcal{O}(|V|^3)\)


\subsection{Zuordnungsprobleme}

\subsubsection{Paare in bipartiten Graphen}
TODO

\subsubsection{Paarungsvergrößerung in allgemeinen Graphen}
\begin{itemize}
	\item Suche \((x,y)\) mit ungepaartem \(x\)
	\item Setze \((x,y)\) durch Breitensuche zu einem alternierenden, maximalen Weg ungerader Länge fort
\end{itemize}

\subsubsection{Maximal gewichtete Paarungen}
Man kann eine maximal gewichtete Paarung finden, indem eine maimal gewichtete Kante iterativ durch einen vergrößernden Weg zu einer nächst größeren und maximal gewichteten Paarung vergrößert wird. Aufwand: \(\mathcal{O}(min\{|V|^3, |V| \cdot |E| \cdot log|V|\})\)

\subsection{Stochastische Algorithmen}

\subsubsection{Algorithmen}
\begin{itemize}
	\item Las Vegas Algorithmen: Falls der Algorithmus terminiert, ist das Ergbenis korrekt (nichtdeterministisch)
	\item Monte Carlo Algorithmus: Der Algorithmus terminiert immer, allerdings ist das Ergebnis mit einer bestimmten Wahrscheinlichkeit falsch
\end{itemize}

\subsubsection{Erwartungswert}
\begin{itemize}
	\item Die Zufallsvariable \(X_i\) nimmt mit einer Wahrscheinlichkeit \(p\) einen bestimmten Wert an
	\item \(\mathbb{E}\lbrack \sum X_i \rbrack = \sum \mathbb{E} \lbrack X_i \rbrack\)
\end{itemize}

\subsubsection{Bedingte Wahrscheinlichkeit}
\[Pr\lbrack E_1 | E_2 \rbrack = \frac{Pr \lbrack E_1 \cap E_2 \rbrack}{Pr \lbrack E_2 \rbrack}\]

\subsubsection{SCHNITT}
Solange die Gesamtkantenzahl \(\geq 3\) ist, wähle zufällig eine Kante \((x,y)\), entferne alle \((x,y)\) und verschmelze \(x\) mit \(y\).


\subsection{Spieltheorie}
\begin{itemize}
	\item Jedes 2-Personen-Nullsummenspiel wird durch die Spielmatrix \(M = \lbrack m_{ij} \rbrack_{i,j=1,1}^{m,n}\) beschrieben
	\item Optimale Strategie von \(A\): \(max_i~min_j~M_{ij}\) (maximiert den Mindestgewinn von \(A\))
	\item Optimale Strategie von \(B\): \(min_j~max_i~M_{ij}\) (minimiert den Maximalverlust von \(B\))
	\item Verfolgen \(A\) und \(B\) gemischte Strategien, so gilt: \(\mathbb{E} \lbrack Gewinn(A)\rbrack = p^TMq\)
\end{itemize}

\subsubsection{Minimax Theorem}
Sei $M=\begin{pmatrix}
5 & 6 \\
7 & 4 
\end{pmatrix} $ dann ist $ min_y =  \begin{pmatrix} 
x & 1-x 
\end{pmatrix}
\begin{pmatrix}
5 & 6 \\
7 & 4 
\end{pmatrix} = 0 $ Nullsetzen.\newline $max_x = 
\begin{pmatrix}
5 & 6 \\
7 & 4 
\end{pmatrix}
\begin{pmatrix}
y \\
1-y 
\end{pmatrix} = 0 $ ebenfalls Nullsetzen.
Die Nullstellen entsprechen dem Ergebnis. \newline Also ist $f(x,y)=(max_x,min_y)$ bzw. $(\begin{pmatrix}
max_x \\
1 - max_x
\end{pmatrix}
,
\begin{pmatrix}
min_y \\
1 - min_y
\end{pmatrix} )$ und der Wert ergibt sich durch Einsetzen in $ max_x \cdot min_y \cdot M=f(x,y) = 
\begin{pmatrix} 
x & 1-x 
\end{pmatrix}
\begin{pmatrix}
5 & 6 \\
7 & 4 
\end{pmatrix}
\begin{pmatrix}
y \\
1-y 
\end{pmatrix}$ und von rechts nach links ausrechnen.

\subsubsection{Von Neumanns Minimax Theorem}
\[max_p~min_q~p^TMq = min_q~max_p~p^TMq\]

\subsubsection{Yaos Technik}
Lautzeitabschätzung eines stochastischen Algorithmus \(A\) für ein Problem \(P\).
\begin{itemize}
	\item Worst-Case-Laufzeit: \(max_i~M_{ij}\)
	\item Best-Case-Laufzeit: \(min_j~M_{ij}\)
	\item Deterministische Komplexität \(K_d\) von \(P\): \(min_j~max_i~M_{ij}\)
	\item Stochastische Komplexität \(K_s\) von \(P\): \(max_i~min_j~M_{ij}\)
	\item \(K_s \leq K_d\) 
	\item Verteilungskomplexität \(K_v\): \(max_p~min_q~p^TMq\)
\end{itemize}

\subsubsection{Spielbaumauswertung}
\[Wert(x) = Wert(y) \downarrow Wert(z)\]

TODO: Algorithmus


\subsection{Lineare Programmierung}

\subsubsection{Simplex-Algorithmus}

\begin{minipage}{\textwidth}
SIMPLEX
\begin{lstlisting}[frame=single,numbers=left,mathescape]
Solange ein $c_S > 0$
	Falls alle $b_{is} \geq 0$
		Keine Loesung
	Sonst
		Bestimme $r$ so, dass $\frac{b_r}{b_{rs}} = max_{(b_{is} < 0)}~\frac{b_i}{b_{is}}$
		AUSTAUSCH
\end{lstlisting}
\end{minipage}

\begin{minipage}{\textwidth}
AUSTAUSCH(A, r, s)
\begin{lstlisting}[frame=single,numbers=left,mathescape]
Forall $i \ne r$, $j \ne s$ {
	$a_{ij}' = a_{ij} - \frac{a_{is} \cdot a_{rj}}{a_{rs}}$
}
# Pivotzeile
Forall $i == r$, $j \ne s$ {
	$a_{ij}' = -\frac{a_{ij}}{a_{rs}}$
}
# Pivotspalte
Forall $i \ne r$, $j == s$ {
	$a_{ij}' = \frac{a_{ij}}{a_{rs}}$
}
# Pivot
Forall $i == r$, $j == s$ {
	$a_{ij}' = \frac{1}{a_{rs}}$
}
\end{lstlisting}
\end{minipage}

\subsubsection{Lösen einer Spielmatrix mit Simplexalgorithmus}
\textbf{Gegeben:} \(A = \begin{pmatrix} 5 & 6 \\ 7 & 4 \end{pmatrix}\). Daraus ergibt sich das lineare Programm:
\[\begin{pmatrix} 5 & 6 & -1 & 0 \\ 7 & 4 & -1 & 0 \\ -1 & -1 & 0 & 1 \\ 0 & 0 & 1 & 5 \end{pmatrix}\]

\(\begin{pmatrix} 5 & 5 \\ 5 & 5 \end{pmatrix}\) kann zur Vereinfachung erstmal von der Ausgangsmatrix abgezogen, muss beim Ergebnis allerdings berücksichtigt werden.

\subsubsection{Ausgleichen/Minimieren mit der Maximumsnorm}
\textbf{Ziel:} Minimiere mit Hilfe der Maximusnorm \(\begin{pmatrix} y(-1) & -(-1) \\ y(0) & -1 \\ y(1) & -1 \end{pmatrix}\).
\\\\
Daraus ergibt sich das überbestimmte Gleichungssystem
\[\begin{pmatrix} 1 & -1 \\ 1 & 0 \\ 1 & 1 \end{pmatrix} \begin{pmatrix} x_1 \\ x_2 \end{pmatrix} = \begin{pmatrix} -1 \\ 1 \\ 1\end{pmatrix}.\]
\\\\
Das Gleichungssystem zeigt die invertierten und nicht-invertierten Nebenbedingungen des Linearen Programms:
\[\begin{array}{ccc|c}
	x_0 & x_1 & x_2 \\
	\hline
	-1 & -1 & -1 & 1 \\
	 1 & -1 &  0 & 1 \\
	 1 & -1 &  1 & 1 \\
	-1 &  1 & -1 & 1 \\
	-1 &  1 &  0 & 1 \\
	-1 &  1 &  1 & 1 \\
	\hline
	1 & 0 & 0 & 0 \\
\end{array}\]
Das Lineare Programm kann zeichnerisch oder rechnisch gelöst werden (siehe Klausuraufgabe 7/WS2014).

\subsubsection{Berechnung der Normalform}
Unter Verwendung der Normalform können sukszessive Zeilen in der Reihenfolge \(r=1,2,...,n\) eleminiert werden. Das der Ursprung dabei im Simplex bleibt, muss gelten:
\[a_i - \frac{a_{ir}\cdot a_r}{a_{rr}} \geq 0,~ \forall i>r\]

\paragraph{Algorithmus}
\begin{enumerate}
	\item Prüfe ob Zeile \(i\) eleminiert werden kann
	\item Wende \textit{AUSTAUSCH} an
	\item Streiche Zeile \(i\) und gehe zur nächsten Zeile
\end{enumerate}



\subsection{de Casteljau}
\[\frac{\Delta B_0}{t} \frac{\Delta B_1}{t-1} = C(\Delta B,t)\]


\subsection{Unterteilungsalgorithmen: Algorithmus von Lane und Riesenfeld}
Das Differenzschema existiert nur, wenn \(\alpha(z)\) den Faktor \(1+z\) besitzt oder
\[\alpha(-1) = \sum_{i \in \mathbb{Z}} \alpha_{2i} - \sum_{i \in \mathbb{Z}}\alpha_{2i + 1} = 0\]
gilt.

\subsubsection{Unterteilungsmatrizen}
Die Unterteilungsmatrizen stellen den Algorithmus dar.

\subsubsection{Symbol}
Die Unterteilungsgleichung hat die Darstellung
\[\beta(z) = \alpha(z) \cdot c(z^2).\]

\begin{itemize}
	\item \(\alpha (z) \) ist das Symbol des Unterteilungsalgorithmus und stellt den Algorithmus dar \(\rightarrow\) kann ersetzt werden, um einen beliebigen Algorithmus zu erhalten
\end{itemize}


\subsubsection{Differenzenschema}
\(\beta(z)\) bezeichnet das Differenzenschema zu \(\alpha\).
\[\beta(z) = \frac{\alpha(z)}{1+z}\]
\\\\
Das Differenzenschema zu \(\alpha(z)\) existiert nur, wenn \(\alpha(z)\) den Faktor \((1+z)\) hat, bzw. wenn
\[\alpha(-1) = \sum_{i \in \mathbb{Z}}\alpha_{2i} - \sum_{i \in \mathbb{Z}}\alpha_{2i+1} = 0.\]

\subsubsection{Konvergenz}
Die Funktion \(c^k(x)\) konvergiert gegen eine Funktion \(c_{\infty}(x)\) so, dass
\[sup(x \in \mathbb{R})~|~c_{\infty}(x) - c^k(x)~|~\in \mathcal{O}(4^{-k}).\]

\paragraph{Folgerung 1}
Die skalierten Differenzpolygone \(2^k d^k(x)\) (Ableitungspolygone) konvergieren gegen
\[\frac{d}{dx} c_{\infty}(x).\]

\paragraph{Folgerung 2}
Induktiv folgt aus \textit{Folgerung 1}, dass die \(n\)-te Ableitung
\[\frac{d^n}{dx^n} c_{\infty}(x)\]
der Limesfunktion stückweise konstant ist.


TODO: Türsuche, Sternsuche

\subsection{Optimierungsprobleme Lineare Programmierung}

TODO: AUSTAUSCH Algorithmus
TODO: Hässlicher Grundaufbau
TODO: SIMPLEX + Vertauschungen
