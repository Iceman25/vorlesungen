\chapter{Echtzeitsysteme}

Zusammenfassung der Vorlesung "`Echtzeitsysteme"' von Professor Längle, Professor Hein und Professor Wörn aus dem Sommersemester 2014.\footnote{\url{http://rob.ipr.kit.edu/lehrangebote_728.php}}



\section{Grundlagen für Echtzeitsysteme in der Automatisierung}

Bei Echtzeitsystemen kommt es neben der logischen Korrektheit auch auf die zeitliche Korrektheit der Ergebnisse an.

\subsection{Anforderungen an Echtzeitsysteme}
\begin{itemize}
	\item Rechtzeitigkeit
	\item Gleichzeitigkeit
	\item Verfügbarkeit
\end{itemize}

\subsubsection{Rechtzeitigkeit}
Die Ausgabedaten müssen rechtzeitig berechnet werden und zur Verfügung stehen.

\subsubsection{Gleichzeitigkeit}
Die Gleichzeitigkeit bedeutet, dass die Rechtzeitigkeit für mehrere Aktionen gleichzeitig gewährleistet sein muss.

\subsubsection{Verfügbarkeit}
Die Verfügbarkeit: Echtzeitsysteme müssen über einen längeren Zeitraum hinweg verfügbar sein, einige sogar rund um die Uhr für 24 Stunden. Verfügbarkeit erfordert keine Unterbrechungen des Betriebs für Reorganisationsphasen.


\subsubsection{Varianten zur Angabe einer Zeitbedingung}
\begin{itemize}
	\item Angabe eines genauen Zeitpunkts
	\item Angabe eines spätesten Zeitpunkts
	\item Angabe eines frühesten Zeitpunkts
	\item Angabe eines Zeitintervalles
\end{itemize}

\subsection{Wertfunktionen zur Bewertung von Zeitbedingungen}
\begin{itemize}
	\item Weiche Echtzeitbedingungen: Kann in gewissen Grenzen überschritten werden ohne zu fatalen Systemzuständen zu führen
	\item Feste Echtzeitbedingungen: Bewirken bei Überschreitung einen Abbruch der Aktion
	\item Harte Echtzeitbedigungen: Müssen eingehalten werden, anderenfalls droht Schaden
\end{itemize}


\subsection{Wirkungskette einer Steuerung}
Die Steuerung ist ein Vorgang in einem abgegrenzten System, bei dem eine oder mehrere Größen als Eingangsgrößen andere Größen als Ausgangsgrößen aufgrund der dem System eigenen Gesetzmäßigkeiten beeinflussen.\footnote{DIN 19226}
\begin{enumerate}
	\item Steuerglied
	\item Stellglied
	\item Prozess/Strecke
\end{enumerate}

\subsubsection{Übergangsfunktionen}
\begin{itemize}
	\item Sollwert (Führungsgröße): \(w(t)\)
	\item Steuersignal: \(u(t)\)
	\item Stellgröße: \(y(t)\)
	\item Steuergröße: \(x(t)\)
\end{itemize}

\subsection{Wirkungskette einer Regelung}
Die Regelung ist ein technischer Vorgang in einem abgegrenzten System, bei dem eine technische oder physikalische Größe (Regelgröße oder Istwert), fortlaufend erfasst und durch Vergleich ihres Signales mit dem Signal einer anderen von außen vorgegebenen Größe (Sollwert), im Sinne einer Angleichung an die Führungsgröße beeinflusst wird.\footnote{DIN 19226}

\begin{itemize}
	\item Regler
	\item Stellglied
	\item Prozess/Strecke
	\item Messglied für Istwert
\end{itemize}

\subsubsection{Vorgehen Entwurf eines Reglers}
\begin{enumerate}
	\item Anforderungen definieren, speziell Stabilität, Schnelligkeit, Genauigkeit
	\item Ermitteln des Modells der Strecke
	\item Wahl Reglertyp
	\item Optimieren des Streckenmodells durch Simulation
	\item Realisieren des Reglers, experimentelle Überprüfung und Optimierung
\end{enumerate}



\section{Rechnerarchitekturen}

\subsection{Mikrorechner}
\begin{itemize}
	\item Bestandteile: \textit{Mikroprozessor} (Prozessokern, Steuerwerk, Rechenwerk), Hauptspeicher, IO
	\item Verbindungseinrichtung, Bus-System
	\item Wird durch Peripheriegeräte zum \textit{Mikrorechnersystem}
\end{itemize}


\subsection{Unterbrechungen}
\begin{itemize}
	\item Software Interrupt: Excpetion, Unterbrechungswunsch eines laufenden Programms
	\item Hardware Interrupt: Unterbrechungswunsch durch externe Hardwarekomponenten
	\item Behandlung per \textit{Interrupt Service Routine}, Zwischenspeichern des Prozessorstatus auf den Stackspeicher mit anschließendem Wiederherstellen
	\item Auslösen im Mikroprozessor: Externe Untebrechung, Quitting, Vektor -> Datenbus
	\item Prioritätsebene, gespeichert im Interrupt-Maskenregister (Teil des Steuerregisters)
	\item Viele Prioritätsebenen: Dezentral (Daisy-Chain) oder mittels zentralem Controller
\end{itemize}


\subsection{Microcontrollers}
\begin{itemize}
	\item Prozessor
	\item RAM
	\item ROM, EORPM, EEPROM
	\item Takt
	\item Ein-/Ausgabesteuerung
	\item Unterbrechungssteuerung
	\item Zähler/Zeitgeber
	\item Erweiterungbusschnittstelle
\end{itemize}
Ziel: Möglichst wenig externe Bausteine für eine Steuerungsaufgabe.

\subsubsection{Speicher für Mikrokontroller}
\begin{itemize}
	\item Flüchtiger Speicher (RAM)
	\begin{itemize}
		\item Statischer Speicher
		\item Dynamischer Speicher
	\end{itemize}
	\item Nichtflüchtiger Speicher (ROM)
	\begin{itemize}
		\item Einmal beschreibbar: ROM, PROM
		\item Wiederbeschreibbar: EPROM, EEPROM, FlashRAM
	\end{itemize}
\end{itemize}

\subsubsection{Aufbau Zähler-/Zeitgebereinheit}
\begin{itemize}
	\item Aufgaben: Zählen von Ereignissen, Erzeugen von Impulsfolgen, Messen von Zeiten
	\item Über den internen Datenbus angebunden
	\item Externen Takt notwendig
\end{itemize}

\subsubsection{Watchdog}
\begin{itemize}
	\item Spezieller Zähler, der bei Ablauf einen Reset auslöst
	\item Muss regelmäßig von der Software angesprochen werden ("`Totmannschalter"')
	\item Anbindung über den internen Datenbus
\end{itemize}

\subsubsection{Serielle und parallele Ein-/Ausgabekanäle}
\begin{itemize}
	\item Auswahl der Komponente über den internen Adressbus
	\item Anbindung zur Datenübertragung über den internen Datenbus
\end{itemize}

\subsubsection{Aufbau einer Echtzeit-Ausgabeeinheit}
\begin{itemize}
	\item Ports, deren Verhalten nicht von der Software, sondern von einem Zeitgeber gesteuert werden
	\item Ausgabe idealerweise jitterfrei
\end{itemize}

\subsubsection{Direct Memory Access}
\begin{itemize}
	\item Daten direkt, ohne Beteiligung des Prozessorkerns zwischen Peripherie und Speicher transportieren
	\item Prozessor definiert lediglich Randbedingungen: Speicheradresse, Peripherieadresse, Anzahl Zeichen
	\item Ende der Übertragung durch Unterbrechungssignal
\end{itemize}


\subsection{Busse}

\subsubsection{Datenbuss}
\begin{itemize}
	\item Prozessorabhängig: Mikroprozessor als Master Device
	\item Prozessorunabhängig: Komponenten am PCI-Bus über Pentium-PCI-Bus Bridge ausgelagert
	\item Gepufferter, entkoppelter Bus: Erweiterung des prozessorunabhängigen Bus, da bei einem zentralen Bus langsame Geräten den Bus blockieren $\rightarrow$ Verletzung der Echtzeitbedingungen
\end{itemize}

\subsubsection{Busbetrieb}
\begin{itemize}
	\item (Nicht-)multiplex-Betrieb
	\item Weiter Kriterien: Synchronisationsart, Übertragungsart, Busbreite, Taktfrequenz, Max. Übertragungsrate/Datentransportbreite
\end{itemize}

\subsubsection{Buszuteilung}
\begin{itemize}
	\item Master: Aktiver Zugriff auf den Bus
	\item Slave: Passiver Zugriff auf den Bus
	\item \textbf{Mehrere Busmaster}
	\begin{itemize}
		\item Mehrere Busmaster: Verfahren zur Zuteilung notwenig. Kann im einfachsten Fall durch den Mikroprozessor geschehen
		\item Externer Bus-Arbiter: Schiedsrichter über die Bus-Zuteilung, Master muss aktiven Zustand anfordern. Aufbau wahlweise zentral oder dezentral per Daisy Chain
	\end{itemize}
\end{itemize}

\subsubsection{Echtzeitaspekte von Systembussen}
\begin{itemize}
	\item Zeitliche Vorhersagbarkeit von zentraler Bedeutung
	\item Einfaches System, synchroner Bus, keine Wartezyklen: Deterministisches Zeitverhalten
	\item Einfaches System, synchroner Bus, Wartezyklen: Wenn Wartezyklen bekannt, dann deterministisch, ansonsten Obergrenze einführen
	\item Mehrere Busmaster: Echtzeitverhalten vom Verhalten im Konfliktfall abhängig
\end{itemize}

\subsubsection{PCI-Bus Transferarten}
\begin{itemize}
	\item Standardtransfer: <Adresse>(<Wartezyklus>)<Datum>
	\item Bursttransfer: <Adresse>(<Wartezyklus>)<Datum><Datum><Datum>
\end{itemize}


\subsection{VME-Bus}

Echtzeitfähiges Bussystem, war lange Zeit das dominierende System für Automatisierungsrechner, wird allerdings zunehmend durch den PCI-Bus verdrängt (höhere Übertragungsraten).

\subsubsection{Wichtige Eigenschaften}
\begin{itemize}
	\item Prozessorunabhängigkeit
	\item Signal-orientiert und asynchron
	\item Kein Multiplex, burst-fähig, fehlererkennend
\end{itemize}

\subsubsection{Transfer}
\begin{itemize}
	\item Einzeltransfer: Einzelne Adresse über den Adressbus, einzelnes Datum über den Datenbus
	\item 32-Bit-Bursttransfer: Einzelne Adresse über den Adressbus, mehrere Daten über den Datenbus
	\item 64-Bit-Bursttransfer: Gemeinsame Nutzung von Daten- und Adressbus, jeweils im Burstmodus
	\item Bestandteile: Bus-Manager, Bus-Master, Bus-Slave
\end{itemize}


\subsection{Schnittstellenbausteine}
Verbindung von Mikrorechner und Umwelt.
\begin{itemize}
	\item Pufferung von IO
	\item Umsetzung der Daten (z.B. parallel $\leftrightarrow$ seriell oder digital $\leftrightarrow$ analog)
	\item Erzeugen von Steuer- und Handshake-Signalen
	\item Annahme und Erzeugen von Unterbrechungsanforderungen
	\item Werden wie Speicher durch IO angesprochen
\end{itemize}



\section{Hardwareschnittstelle zwischen Echtzeitsystem und Prozess}

\subsection{Netzberechnung}
\begin{itemize}
	\item Knotenregel: Die Summe aller Ströme in einem Knoten ist $0$, es entstehen oder verschwenden keine Ströme.
	\item Maschenregel: Die Summe aller Spannungen in einer Masche ist $0$.
\end{itemize}


\subsection{Transistoren}
Grundbaustein aller elektrischen Schaltungen.

\subsubsection{Transistor als Verstärker}
Es ergibt sich eine Leistungsverstärkung, da sowohl Spannung, als auch Strom verstärkt werden.


\subsubsection{Transistor als Schalter}
Der Transistor wird lediglich in den Zuständen \textit{Sättigung} und \textit{Gesperrt} ($U_{BE} < 0,6 V$) betrieben.


\subsection{AD-Wandler}

\subsubsection{Wägeverfahren}
\begin{itemize}
	\item \textbf{Bestandteile}
	\begin{itemize}
		\item Abtast-Halte-Glied: Hält die Eigangsspannung wärend des Abtastvorgangs konstant
		\item Komparator: Vergleicht die Engangsspannung
		\item Datenspeicher
		\item Steuerlogik
		\item Taktgenerator
	\end{itemize}
	\item \textbf{Vorgehen}
	\begin{enumerate}
		\item Setze alle Bits im Datenspeicher gleich $0$
		\item Beginnend beim höchstwertigen Bits werden schrittweise alle Bits des Digitalwerts ermittelt, in dem über einen DA-Wandler Referenzspannungen generiert werden
	\end{enumerate}
\end{itemize}

\subsubsection{Kompensationsverfahren}
\begin{itemize}
	\item Nutzt ebenfalls generierte Spannungen als Referenz
	\item Zähler, der vorwärts und rückwärts zählen kann, hält den zu wandelten Wert
	\item Koparatorergebnis steuert die Zählrichtung
	\item Ergebnis in maximal $N$ Schritten vorhanden
\end{itemize}

\subsubsection{Parallelverfahren}
\begin{itemize}
	\item Vergleich der Eingangsspannung mit $2^n-1$ Referenzspannungen über einen Spannungsteiler und speichert die Resultate in Flip-Flops
	\item Schnellstes Verfahren, kann Signale im GHz-Bereich verarbeiten
	\item Nachteil: Hoher Aufwand und hohe Zahl an Bauelementen
\end{itemize}

\subsubsection{Vergleich verschiedener Verfahren}
Auswahl des Verfahrens nach Zielfrequenz und Zielauflösung.
\begin{itemize}
	\item Kompensationsverfahren, Zählverfahren
	\item Wägeverfahren
	\item Parallelverfahren
\end{itemize}


\subsection{Asynchrone Datenübertragung}

\subsubsection{Rs-232}

\begin{itemize}
	\item Space ($+$, Übertragung der $0$) und Mark ($-$, Übertragung der $1$)
	\item \textbf{Verfahren}
	\begin{enumerate}
		\item Ruhepegel
		\item Statusbit ($0$)
		\item Übertragung des Datums, LSB $\rightarrow$ MSB
		\item Stopbit ($1$, 2x)
		\item Ruhepegel
	\end{enumerate}
\end{itemize}

\subsubsection{RS-422}
Analog wie RS-232, alelrdings größere Entfernung (1200 m) und höhere Datenraten (100 kBit/s).



\section{Echtzeitkommunikation}

\subsection{Zugriffsverfahren auf Echtzeitkommunikationssysteme}
\begin{itemize}
	\item Polling
	\item CSMA/CD und CSMA/CA
	\item Token-Passing
	\item TDMA (Time Division Multiple Access)
\end{itemize}


\subsection{Netzwerkprotokolle}

\subsubsection{Ethernet-Frame}
\begin{itemize}
	\item \textbf{Header}
	\begin{itemize}
		\item Präambel: Wechselnde 4 Bit Folge zur Synchonisation
		\item Start Frame Delimeter: Beginn des Adressfeld
		\item Zieladresse
		\item Quelladresse
	\end{itemize}
	\item Datenfeld: 46 - 1500 Byte
	\item CRC-Checksummer (Trailer)
\end{itemize}

\subsubsection{Internet Controll Message Protocol (ICMP)}
\begin{itemize}
	\item Flusskontroller
	\item Erkennen von unerreichbaren Zielrechnern
	\item Routenoptimierung
	\item Überprüfen von erreichbaren Hosts
\end{itemize}


\subsection{Profibus}
PROFIBUS (Process Field Bus) ist ein Standard für die Feldbus-Kommunikation in der Automatisierungstechnik.\footnote{\url{http://de.wikipedia.org/wiki/Profibus}}

\subsubsection{Hybrides Zugriffsverfahren}
\begin{itemize}
	\item Token-Passing unter den aktiven Stationen (Multi-Master)
	\item Polling zwischen einem Master und den dazugehörigen Slaves
\end{itemize}


\subsection{Interbus}
Interbus ist ein Feldbussystem für einen breiten Einsatz in einem Unternehmen. Interbus deckt verschiedene Applikationsbereiche ab, von Sensor/Aktor-Ebene in der Prozess-Automatisierung, bis zu Überwachungs-PC.\footnote{\url{http://de.wikipedia.org/wiki/Interbus}}

\subsubsection{Eigenschaften}
\begin{itemize}
	\item Topologie: Aktiver Ring
	\item Buslänge: Fernbus max. 12,8 km und Pripheriebus max. 10 m
	\item Übertragungsrate: 500 kBit/s
	\item Buszugriffsverfahren: Festes Zeitraster
	\item Busverwaltung: Monomaster
\end{itemize}

\subsubsection{Komponententypen}
\begin{itemize}
	\item Master
	\item Busklemme zur Verzweigung
	\item IO-Modul (Peripheriebusgerät)
	\item IO-Modul (Fernbusgerät)
\end{itemize}



\section{Echtzeitprogrammierung}
Das Ergebnis von Echtzeit-Datenverarbeitung ist nur dann korrekt, wenn es logisch und zeitlich korrekt ist.


\subsection{Synchrone Programmierung}
\begin{itemize}
	\item Zeitliches Verhalten periodischer Aktionen ist vorgeplant
	\item Die periodischen Aktionen werden in einem Zeitraster synchronisiert
	\item Die Reihenfolge des Ablaufs ist fest vorgegeben
	\item \textbf{Vorteile}
	\begin{itemize}
		\item Festes, vorhersagbares Zeitverhalten
		\item Einfaches Analyse und Testen
		\item Gut für zyklische Abläufe anwendbar
		\item Kann bei guter Planung Rechtzeitigkeit und Gleichzeitigkeit garantieren
	\end{itemize}
	\item \textbf{Nachteile}
	\begin{itemize}
		\item Geringe Flexibilität gegenüber Änderungen
		\item Reaktionen auf aperiodische Ereignisse sind nicht vorgesehen (synchron nur durch periodische Überwachung möglich)
	\end{itemize}
\end{itemize}


\subsection{Asynchrone Programmierung}
Ablaufplanung der Aktionen zur Laufzeit durch ein Organisationsprogramm (Echtzeitbetriebssystem).

\begin{itemize}
	\item Flexibler Programmablauf und flexible Programmstruktur
	\item Reaktion auf periodische und aperiodische Ereignisse
	\item Rechtzeitigkeit nicht immer im Voraus garantierbar
	\item Systemtests und Systemanalyse schwierig
\end{itemize}

\subsubsection{Aufgaben des Organisationsprogramms (Echtzeitscheduling)}
\begin{itemize}
	\item Ereignisse überwachen
	\item Informationen über Zeitbedingungen entgegennehmen
	\item Ablaufreihenfolge von Teilprogrammen der eingetretenen Ereignisse ermitteln
	\item Teilprogramme gemäß der ermittelten Ablaufreihenfolge aktivieren
\end{itemize}

\subsubsection{Fixed Priority Preemptive Scheduling}
\begin{itemize}
	\item Feste Prioritäten, Reihenfolge der Ausführung richtet sich danach
	\item Ereignisse mit hoher Priorität unterbrechen Ereignisse mit niedriger Priorität
	\item Bearbeitung des niedrig priorisieten Ereignisses wird erst wieder aufgenommen, wenn alle höher priorisierten abgearbeitet sind
\end{itemize}



\section{Echtzeitbetriebssysteme}

\subsubsection{Aufgaben eines Echtzeitbetriebssystems}
\begin{itemize}
	\item Taskverwaltung
	\item Betriebsmittelverwaltung
	\item Interprozesskommunikation
	\item Synchronisation der Tasks
	\item Schutz der Betriebsmittel vor unberechtigtem Zugriff von Tasks
	\item Wahrung der Rechtzeitigkeit und Gleichzeitigkeit
	\item Wahrung der Verfügbarkeit
\end{itemize}


\subsection{Makrobetriebssystem}

\subsubsection{Schichtenmodell eines Makrobetriebssystems}
\begin{itemize}
	\item Anwendung
	\item API/Shell
	\item Taskverwaltung
	\item Betriebsmittelverwaltung
	\item Speicherverwaltung/IO-Verwaltung
	\item IO-Steuerung
	\item Gerätetreiber
	\item Prozessor
\end{itemize}


\subsection{Mikrobetriebssystem}

\subsubsection{Schichtenmodell eines Mikrobetriebssystems}
\begin{itemize}
	\item \textbf{Erweiterungsmodule}
	\begin{itemize}
		\item Anwendung
		\item API/Shell
		\item Taskverwaltung
		\item Betriebsmittelverwaltung
		\item Speicherverwaltung/IO-Verwaltung
		\item IO-Steuerung
		\item Gerätetreiber
	\end{itemize}
	\item \textbf{Mikrokern}
	\begin{itemize}
		\item Kommunikation der Module
		\item Erweiterungsmodule im Userspace
		\item Interprozesskommunikation
		\item Synchronisation
		\item Taskverwaltung
	\end{itemize}
	\item Prozessor
\end{itemize}

\subsubsection{Vorteile}
\begin{itemize}
	\item Sehr gut an die Aufgabe anpassbar
	\item Hohe Skalierbarkeit durch Erweiterungsmodule
	\item Einfache Portierbarkeit
	\item Preemptiver Kern
	\item Kurze kritische Bereiche
\end{itemize}


\subsection{Echtzeitscheduling}
Aufteilung des Prozessors zwischen allen ablaufwilligen Tasks derart, dass - sofern möglich - alle Zeitbedingungen eingehalten werden.


\subsection{Scheduling-Verfahren}

\subsubsection{FirstIn-FirstOut}
\begin{itemize}
	\item Wer zuerst kommt erhält den Prozessor
	\item Dynamisch, nicht-preemptive, ohne Prioritäten
	\item Wenig geeignet für Echtzeit, da keinerlei Zeitbedingungen
\end{itemize}

\subsubsection{Fixed-Priority-Scheduling}
\begin{itemize}
	\item Jeder Task erhält fixe Piorität
	\item Dynamisches Scheduling, statische Prioritäten
	\item Wahlweise (nicht-)preemptiv
\end{itemize}

\subsubsection{Earliest-Deadline-Fist-Scheduling}
\begin{itemize}
	\item Diejenige Task, die am nächsten an der eigenen Zeitschrank ist, erhält den Prozessor
	\item Scheduling und Prioritäten ergeben sich dynamisch
	\item Wahlweise (nicht-)preemptiv
\end{itemize}

\subsubsection{Least-Laxity-First-Scheduling}
\begin{itemize}
	\item Diejenige Task, die den geringsten Spielraum hat, erhält den Prozessor
	\item Dynamisches Scheduling mit dynamischen Prioritäten
	\item Wahlweise (nicht-)preemptiv
	\item Vergleich zu EDF: Deutlich mehr Taskwechsel, allerdings besser bei Überlast
\end{itemize}

\subsubsection{Time-Slice-Scheduling}
\begin{itemize}
	\item Zuordnen von individuellen, festen Zeitscheiben
	\item Preemptives, dynamische Scheduling ohne Prioritäten
\end{itemize}

\subsubsection{Guaranteed Percentage Scheduling}
\begin{itemize}
	\item Zuordnen von festen Prozentsätzen der verfügbaren Prozessorleitung innerhalb einer Periode
	\item Preemptives, dynamische Scheduling ohne Prioritäten
	\item Auf Einprozessorsystem ein optimales Verfahren
\end{itemize}


\subsection{Synchronisation}

\subsubsection{Gemeinsame Betriebsmittel}
\begin{itemize}
	\item Daten
	\item Geräte
	\item Programme
\end{itemize}

\subsubsection{Synchronisationsvarianten}
\begin{enumerate}
	\item Sperrsynchronisation mit Mutex (wechselseitiger Ausschluss), bei belegtem Mutex wird die zugreifende Task verzögert, bis der Mutex frei ist
	\item Reihenfolgensynchronisation mit Semaphoren, Operationen: Passiere, Verlasse
\end{enumerate}

\subsubsection{Deadlocks}
Mehrere Tasks warten auf die Freigabe von Betriebsmitteln, die sich gegenseitig blockieren.

\subsubsection{Gegenmaßnahmen}
\begin{itemize}
	\item Abhängigkeitsanalyse
	\item Vergabe der Betriebsmittel in gleicher Reihenfolge
	\item Timeout
\end{itemize}

\subsubsection{Livelocks}
Eine Task wird durch andere Tasks ständig an der Ausführung gehindert.


\subsection{Kommunikation zwischen Tasks}
\begin{itemize}
	\item Gemeinsamer Speicher
	\item Austausch von Nachrichten
\end{itemize}


\subsection{IO-Verwaltung}

\subsubsection{Aufgaben}
\begin{itemize}
	\item Zuteilung und Freigeben von Geräten
	\item Benutzen von Geräten
\end{itemize}
Schwierigkeit: Bieten einer transparenten Schnittstelle bei sehr unterschiedlichen Geräten, die sich in Geschwindigkeit und Datenformat stark unterscheiden.

\subsubsection{Aufgaben im Detail}
\begin{itemize}
	\item Symbolische Namensgebung
	\item Synchronisation und Schutz der Geräte
	\item Kommunikation mit den Gerätetreibern über Schnittstellenbausteine
	\item Pufferung und einheitliches Datenformt
\end{itemize}

\subsubsection{Synchronisationsmechanismen}
\begin{itemize}
	\item Polling: Einfach und hohe Übertragungsleistung, allerdings ist der Prozessor ständig aktiv, keine Nebenaktivitäten
	\item Busy Waiting (Periodisches Einschieben von Nebenaktivitäten): Nebenaktivität möglich, allerdings verlangsamte Reaktionszeit und Nebenaktivitäten müssen in kleine Teilschritte unterteilt werden
	\item Interrupt: Beliebige Nebenaktivitäten, schnelle Übertragung, allerdings verringerte Übertragungsraten
	\item Polling mit Handshake: Zusätzlicher Handshake notwendig, falls das Gerät schneller liefert als die Task sie entgegennehen kann
	\item Interrupt mit Handshake: s.o.
\end{itemize}


\subsection{Auswahlkriterien für Echtzeitbetriebssysteme}
\begin{enumerate}
	\item Entwicklungs- und Zielumgebung: Programmiersprache, Zielsystem, Cross-Entwicklung
	\item Modularität und Kerngröße: Konfigurierbarkeit der Anwendung, minimaler Mikrokern für eingebettete Systeme
	\item Anpassbarkeit an verschiedene Zielumgebungen für Automatisierung
	\item Allgemeine Eigenschaften: Shell, Bibliotheken, Werkzeuge
	\item Leistungsdaten
\end{enumerate}

\subsubsection{QNX-Architektur}
\begin{itemize}
	\item Anwendertasks
	\item Systemtasks
	\item Mikrokern
	\item Hardware
\end{itemize}

\subsubsection{Architektur von RTLinux}
\begin{itemize}
	\item Hardware-Echtzeitkern
	\item Linuxkern ist Echtzeitanwendung neben Echtzeittasks
	\item Echtzeit-FIFO
	\item RT-Prozesse werden über Kernel-Module definiert und geladen
\end{itemize}



\section{Appendix A: Operationsverstärker}

\subsubsection{Der ideale Operationsverstärker: Annahmen}
\begin{itemize}
	\item Verstärkung ist unendlich
	\item Der Eingangswiderstand ist unendlich
	\item Der Ausgangswiderstand ist null
\end{itemize}

\subsubsection{Eigenschaften}
\begin{itemize}
	\item Verstärkt die Differenz $U_D$ der beiden anliegenden Spannungen
	\item Die Versorgungsspannungen legen den maximalen und den minimalen Ausgangsbereich fest
	\item Verstärkung ist linear
\end{itemize}

\subsubsection{Grundsätzliche Beschaltung}
\begin{itemize}
	\item Eingangssignal wird auf den positiven Eingang gelegt
	\item Ausgangssignal wird auf den negativen Eingang rückgekoppelt
\end{itemize}

\subsubsection{Ausgangsspannung}
\[U_A = Y_D \cdot (U_P - U_N) = Y_D \cdot U_D\]


\subsection{Operationsverstärker als Vergleicher}
\begin{itemize}
	\item $U_{E1} > U_{E2} \rightarrow U_A = U_{CC}$
	\item $U_{E1} < U_{E2} \rightarrow U_A = U_{EE}$
\end{itemize}


\subsection{Nicht-invertierter Spannungsverstärker}
Die Verstärkung der Schaltung muss immer größer oder gleich eins sein.

\[Y = \frac{U_A}{U_E} = \frac{R_1 + R_N}{R_1}\]



\section{Appendix B: Formelsammlung}

\subsection{Busse}

\subsubsection{Übertragungsrate}
\[\frac{AnzahlBytes}{Taktzykluszeit \cdot Anzahl~Taktzyklen}\]


\subsection{Transistor}
$\beta$ bezeichnet den \textit{Stromverstärkungsfaktor} des Transistors.

\subsubsection{Spannungsverstärkung}
\[V_U = \frac{-R_C}{R_B} \cdot \beta\]

\subsubsection{Leistungsverstäkung}
\[V_L = V_U \cdot \beta\]


\subsection{Echtzeitbetriebssysteme}

\subsubsection{Prozessorauslastung}
\[H = \frac{Benoetigte~Prozessorzeit}{Verfuegbare~Prozessorzeit}\]

\subsubsection{Prozessorauslastung Taskset auf Einprozessorsystem}
\[H = \sum_{i=1}^{n}\frac{Ausfuehrungszeit_i}{Periodendauer~Task_i}\]
